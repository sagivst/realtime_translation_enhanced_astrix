/**
 * Hume AI Streaming Client - Lightweight real-time emotion detection
 * Provides: Arousal, Valence, Energy metrics for dashboard monitoring
 */

const WebSocket = require('ws');
const EventEmitter = require('events');

class HumeStreamingClient extends EventEmitter {
    constructor(apiKey, options = {}) {
        super();
        this.apiKey = apiKey;
        this.ws = null;
        this.connected = false;
        this.metrics = {
            arousal: 0,
            valence: 0,
            energy: 0,
            timestamp: null,
            voiceDetected: false
        };
        
        this.config = {
            sampleRate: options.sampleRate || 16000,
            channels: options.channels || 1,
            models: options.models || {
                prosody: {}
            }
        };
    }

    async connect() {
        return new Promise((resolve, reject) => {
            try {
                // Hume AI WebSocket endpoint for streaming prosody
                const wsUrl = `wss://api.hume.ai/v0/stream/models?apikey=${this.apiKey}`;
                
                console.log('[Hume] Connecting to Hume AI streaming...');
                this.ws = new WebSocket(wsUrl);

                this.ws.on('open', () => {
                    console.log('[Hume] âœ“ Connected to Hume AI');
                    this.connected = true;
                    
                    // Send configuration
                    const config = {
                        models: this.config.models,
                        raw_text: false
                    };
                    
                    this.ws.send(JSON.stringify(config));
                    console.log('[Hume] Configuration sent:', JSON.stringify(config));
                    
                    this.emit('connected');
                    resolve();
                });

                this.ws.on('message', (data) => {
                    try {
                        const response = JSON.parse(data.toString());
                        this.handleResponse(response);
                    } catch (err) {
                        console.error('[Hume] Error parsing message:', err.message);
                    }
                });

                this.ws.on('error', (error) => {
                    console.error('[Hume] WebSocket error:', error.message);
                    this.emit('error', error);
                });

                this.ws.on('close', () => {
                    console.log('[Hume] Connection closed');
                    this.connected = false;
                    this.emit('disconnected');
                });

            } catch (error) {
                console.error('[Hume] Connection error:', error.message);
                reject(error);
            }
        });
    }

    handleResponse(response) {
        // Log raw response for debugging
        if (response.prosody) {
            console.log('[Hume] Prosody data received:', JSON.stringify(response.prosody).substring(0, 200));
            
            const prosody = response.prosody;
            
            // Extract metrics - Hume provides various emotional dimensions
            // We'll map the most relevant ones to arousal, valence, energy
            if (prosody.predictions && prosody.predictions.length > 0) {
                const pred = prosody.predictions[0];
                
                // Map Hume's emotional dimensions to our metrics
                // Arousal: high activation emotions (excitement, anger, fear)
                // Valence: positive vs negative (joy vs sadness)
                // Energy: speech intensity and dynamism
                
                const emotions = pred.emotions || [];
                
                // Calculate arousal (0-1): activation level
                const arousalEmotions = ['excitement', 'anger', 'fear', 'surprise'];
                this.metrics.arousal = this.calculateMetric(emotions, arousalEmotions);
                
                // Calculate valence (0-1): positivity
                const positiveEmotions = ['joy', 'contentment', 'amusement', 'love'];
                const negativeEmotions = ['sadness', 'anger', 'fear', 'disgust'];
                const positive = this.calculateMetric(emotions, positiveEmotions);
                const negative = this.calculateMetric(emotions, negativeEmotions);
                this.metrics.valence = Math.max(0, Math.min(1, (positive - negative + 1) / 2));
                
                // Calculate energy (0-1): speech dynamics
                const energyEmotions = ['excitement', 'determination', 'concentration'];
                this.metrics.energy = this.calculateMetric(emotions, energyEmotions);
                
                this.metrics.timestamp = new Date().toISOString();
                this.metrics.voiceDetected = true;
                
                console.log('[Hume] Metrics updated:', {
                    arousal: this.metrics.arousal.toFixed(3),
                    valence: this.metrics.valence.toFixed(3),
                    energy: this.metrics.energy.toFixed(3)
                });
                
                this.emit('metrics', this.metrics);
            }
        }
        
        // Handle other response types
        if (response.error) {
            console.error('[Hume] API error:', response.error);
            this.emit('error', new Error(response.error.message || 'Hume API error'));
        }
    }

    calculateMetric(emotions, targetEmotions) {
        if (!emotions || emotions.length === 0) return 0;
        
        let total = 0;
        let count = 0;
        
        emotions.forEach(emo => {
            if (targetEmotions.includes(emo.name.toLowerCase())) {
                total += emo.score;
                count++;
            }
        });
        
        return count > 0 ? total / count : 0;
    }

    sendAudio(audioBuffer) {
        if (!this.connected || !this.ws || this.ws.readyState !== WebSocket.OPEN) {
            return;
        }

        try {
            // Hume expects base64-encoded audio
            const base64Audio = audioBuffer.toString('base64');
            
            const payload = {
                data: base64Audio,
                models: this.config.models
            };
            
            this.ws.send(JSON.stringify(payload));
        } catch (error) {
            console.error('[Hume] Error sending audio:', error.message);
        }
    }

    getMetrics() {
        return { ...this.metrics };
    }

    async disconnect() {
        if (this.ws) {
            this.ws.close();
            this.ws = null;
        }
        this.connected = false;
    }
}

module.exports = HumeStreamingClient;
