# AI Audio Optimization – Data Model & Station Snapshot Specification

**Version:** 2.1.0  
**Date:** December 2025  
**Audience:** Backend developers, data engineers, DevOps, gateway/server developers

---

## 0. Purpose of This Document

This document defines the **authoritative specification** for the AI Audio Optimizer data model and the **Station Snapshot** wire format.

It is aligned with the *current, real* snapshot payloads generated by the system (as observed in production/test logs) and is designed to be:

- **Strict for mandatory structure** (hard schema for required fields).  
- **Flexible for metrics and station expansion** (no code changes needed when adding new metrics or stations).  
- **Forward-compatible** with future additions such as segments, audio references, constraints, and optimization targets.

The spec consists of:

1. Entity & hierarchy model (Calls → Channels → SessionConfigs → Segments → StationSnapshots).  
2. Real-time behavior of knob sets and metrics.  
3. Station Snapshot JSON wire format.  
4. Hard JSON Schema (Draft 2020‑12) that validates the current, real payloads.  
5. Notes on evolution and usage rules.

---

## 1. High-Level Hierarchy (Conceptual Model)

The optimizer reasons per **call**, with two **channels** and multiple **stations** monitoring each channel over time.

```text
Call
 ├── Channel: caller (or leg A)
 │     ├── SessionConfig (caller knob set)
 │     └── Segments
 │           └── StationSnapshots (per station, per segment)
 └── Channel: callee (or leg B)
       ├── SessionConfig (callee knob set)
       └── Segments
             └── StationSnapshots (per station, per segment)
```

Key points:

- Every **Station Snapshot** belongs logically to a **segment**, which belongs to a **channel**, which belongs to a **call**.
- In the current implementation, the **runtime snapshot JSON** is *flatter* (no explicit embedded `segment` object yet), but the **database model** and future transport format support full hierarchy.
- Each channel has its **own knob set** (SessionConfig) which is applied to audio packets in real time.

---

## 2. Persistent Data Model (Database Level)

> This section describes the canonical database model. Some fields do not yet appear in the live snapshot JSON but MUST be supported in the DB schema for future features.

### 2.1 `calls`

Represents one full communication session.

```text
calls
------
id (UUID PK)
external_call_id
created_at
ended_at
direction             -- inbound / outbound
metadata (JSONB)
```

### 2.2 `channels`

Each call has exactly two channels: *caller* and *callee* (or legs A/B).

```text
channels
--------
id (UUID PK)
call_id        (FK → calls.id)
name           ("caller" / "callee")
leg            ("A" / "B")
metadata       (JSONB)
```

### 2.3 `session_configs`

Holds the active knob set per channel.

```text
session_configs
---------------
id (UUID PK)
call_id         (FK → calls.id)
channel_id      (FK → channels.id)
role            ("caller" / "callee")
knobs           (JSONB)  -- array of { name, value }
version         (INTEGER)
active          (BOOLEAN)
created_at
updated_at
```

Example `knobs` JSON:

```json
{
  "knobs": [
    { "name": "agc.target_level_dbfs", "value": -18 },
    { "name": "noise_reduction_strength", "value": 3 }
  ]
}
```

### 2.4 `segments`

Segments divide each channel timeline and tie ranges of audio to a specific knob set.

```text
segments
--------
id (UUID PK)
channel_id         (FK → channels.id)
session_config_id  (FK → session_configs.id)
start_ms           -- inclusive
end_ms             -- exclusive
segment_type       -- speech / silence / event
transcript
transcript_json
created_at
```

### 2.5 `station_snapshots`

Every station creates one snapshot per segment (or at a given sampling strategy).

```text
station_snapshots
-----------------
id (UUID PK)
segment_id        (FK → segments.id)
station_id        ("STATION_3", "STATION_9", etc.)
timestamp         -- UTC
metrics           (JSONB)
audio_ref         (TEXT)      -- pointer to PCM
knobs_effective   (JSONB)     -- copy of session_configs.knobs
constraints       (JSONB)     -- hard limits, optional
targets           (JSONB)     -- optimization goals, optional
optimizer_run_id  (UUID, NULLABLE)
created_at
```

> **Note:** In the current live snapshots, only `id`, `station_id`, `timestamp`, `call_id`, `channel`, `metrics`, `knobs`, and `totals` are transported. The DB model is richer and must support future evolution.

---

## 3. Real-Time Logic (Two-Knob Model)

At runtime, audio is processed per call and per channel with its own knob set.

### 3.1 In-Memory Knob Sets

```text
live_knobs[call_id]["caller"] = SessionConfig for caller
live_knobs[call_id]["callee"] = SessionConfig for callee
```

### 3.2 Packet Processing

For each audio packet:

1. Determine `channel` (caller / callee).  
2. Apply the corresponding knob set:

```text
apply(live_knobs[call_id][channel], packet.audio_frame)
```

3. Stations measure metrics such as SNR, jitter, packet loss, latency, synthesis quality, etc.  
4. For each measurement tick, a **Station Snapshot** is created that contains:
   - The current metrics.
   - The *effective* knob set applied at that moment.

### 3.3 Optimizer Feedback Loop

1. AI Optimizer receives a batch of Station Snapshots (per call, per channel, per station).  
2. It suggests updated knob values per channel (e.g., change AGC, NR strength, AEC enabled).  
3. System writes a new `session_configs` row with incremented `version`.  
4. `live_knobs` are updated; subsequent packets are processed with the new configuration.  
5. New Station Snapshots reflect the updated knobs.

---

## 4. Station Snapshot – Transport Format (Wire JSON)

### 4.1 General Rules

- **Encoding:** JSON, UTF‑8.  
- **Direction:** Station → Optimizer (HTTP POST, WebSocket, or similar).  
- **Granularity:** 1 snapshot per station per channel per time slice (implementation-specific window).  
- **Immutability:** Snapshots are *append-only*. No in-place modification.  
- **Idempotency:** `id` is a UUID that uniquely identifies a snapshot. Re-sending the same snapshot with the same `id` must be treated as idempotent by the Optimizer.

### 4.2 Current Minimal Required Fields

The *current* (real) production/test payloads contain at least:

- `id` – snapshot UUID.  
- `station_id` – monitoring station identifier.  
- `timestamp` – capture time in ISO 8601 UTC format.  
- `call_id` – logical call identifier.  
- `channel` – `"caller"` or `"callee"` (or `"A"` / `"B"`).  
- `metrics` – object of numeric (or `null`) values.  
- `knobs` – array of `{ name, value }` pairs.  
- `totals` – object with summary counts (optional but recommended).

Example (truncated from live data):

```json
{
  "id": "b60b8e02-0636-488a-b792-16df775e394d",
  "station_id": "STATION_3",
  "timestamp": "2025-11-30T18:05:01.677Z",
  "call_id": "call-1764533101668",
  "channel": "caller",
  "metrics": {
    "snr_db": 28.5,
    "jitter_ms": 12.3,
    "cpu_usage_pct": 28.1,
    "noise_floor_db": -65,
    "packet_loss_pct": 0.1,
    "audio_level_dbfs": -18,
    "buffer_underruns": 0,
    "buffer_usage_pct": 52.3,
    "voice_activity_ratio": 0.72,
    "end_to_end_latency_ms": 187,
    "processing_latency_ms": 42,
    "transcription_accuracy": 0.94,
    "transcription_latency_ms": 145,
    "...": null
  },
  "knobs": [
    { "name": "input_gain_db", "value": 2 },
    { "name": "agc.target_level_dbfs", "value": -18 },
    { "name": "noise_reduction_strength", "value": 3 },
    { "name": "deepgram.model", "value": "nova-2" },
    { "name": "deepgram.language", "value": "en" },
    { "name": "deepgram.punctuate", "value": true }
  ],
  "totals": {
    "knobs_count": 6,
    "metrics_count": 14
  }
}
```

> All additional metrics are allowed as long as they are numeric or `null`. The Optimizer treats unknown metrics as optional features.

### 4.3 Future (Optional) Fields

The schema explicitly supports the following optional fields for future evolution:

- `schema_version` – string, used for versioning the snapshot schema.  
- `segment` – object with `segment_id`, `start_ms`, `end_ms`.  
- `audio` – PCM reference (`sample_rate`, `format`, `duration_ms`, `storage_key`).  
- `constraints` – hard limits and rule flags.  
- `targets` – optimization goals and weights.  

These fields are **not required** by the hard schema but are strongly recommended when the corresponding features are implemented.

---

## 5. Hard JSON Schema (Draft 2020‑12)

The following JSON Schema:

- Is **strict** about the required top-level structure.  
- Allows **any metrics** inside the `metrics` object (values are numbers or `null`).  
- Allows future addition of stations without changing the schema.  
- Allows optional future objects (`segment`, `audio`, `constraints`, `targets`, `totals`).  
- Forbids unknown top-level fields (`additionalProperties: false`), so all new top-level fields must be properly added to the schema.

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Station Snapshot Schema",
  "type": "object",
  "additionalProperties": false,

  "required": [
    "id",
    "station_id",
    "timestamp",
    "call_id",
    "channel",
    "metrics",
    "knobs"
  ],

  "properties": {
    "schema_version": {
      "type": "string",
      "description": "Optional schema version identifier, e.g. '2.1.0'."
    },

    "id": {
      "type": "string",
      "format": "uuid",
      "description": "Globally unique snapshot identifier."
    },

    "station_id": {
      "type": "string",
      "pattern": "^STATION_[0-9]+$",
      "description": "Monitoring station identifier, e.g. 'STATION_3'. Schema is flexible and supports future stations without change."
    },

    "timestamp": {
      "type": "string",
      "format": "date-time",
      "description": "UTC timestamp of snapshot capture (ISO 8601)."
    },

    "call_id": {
      "type": "string",
      "description": "Logical call identifier as used by the telephony system."
    },

    "channel": {
      "type": "string",
      "enum": ["A", "B", "caller", "callee"],
      "description": "Channel role. In current implementation, 'caller' and 'callee' are used, but 'A' and 'B' are reserved."
    },

    "segment": {
      "type": "object",
      "description": "Optional segment information (future).",
      "required": ["segment_id", "start_ms", "end_ms"],
      "properties": {
        "segment_id": {
          "type": "string"
        },
        "start_ms": {
          "type": "number",
          "minimum": 0
        },
        "end_ms": {
          "type": "number",
          "minimum": 0
        },
        "segment_type": {
          "type": "string",
          "description": "Optional type (speech/silence/event)."
        }
      },
      "additionalProperties": false
    },

    "metrics": {
      "type": "object",
      "description": "Measured metrics for this station, channel, and time slice.",
      "additionalProperties": {
        "type": ["number", "null"]
      }
    },

    "audio": {
      "type": "object",
      "description": "Optional reference to stored PCM audio for this snapshot.",
      "required": ["sample_rate", "format", "storage_key"],
      "properties": {
        "sample_rate": { "type": "number" },
        "format": { "type": "string" },
        "duration_ms": { "type": ["number", "null"] },
        "storage_key": { "type": "string" }
      },
      "additionalProperties": false
    },

    "knobs": {
      "type": "array",
      "description": "Effective knob set applied at the time of this snapshot.",
      "items": {
        "type": "object",
        "required": ["name", "value"],
        "properties": {
          "name": {
            "type": "string"
          },
          "value": {
            "type": ["number", "boolean", "string", "null"]
          }
        },
        "additionalProperties": false
      }
    },

    "constraints": {
      "type": "object",
      "description": "Optional hard limits and rule flags for this snapshot.",
      "additionalProperties": {
        "type": ["number", "boolean", "string", "null"]
      }
    },

    "targets": {
      "type": "object",
      "description": "Optional optimization goals for this snapshot.",
      "properties": {
        "goal": { "type": "string" },
        "weights": {
          "type": "object",
          "additionalProperties": { "type": "number" }
        }
      },
      "additionalProperties": {
        "type": ["number", "boolean", "string", "null"]
      }
    },

    "totals": {
      "type": "object",
      "description": "Optional debug/summary information.",
      "properties": {
        "knobs_count": { "type": "number" },
        "metrics_count": { "type": "number" }
      },
      "additionalProperties": false
    }
  }
}
```

---

## 6. Validation & Partial Snapshot Handling

### 6.1 Hard Schema vs. Usage Rules

- The **JSON Schema** enforces the **mandatory structure** only:
  - Required top-level fields: `id`, `station_id`, `timestamp`, `call_id`, `channel`, `metrics`, `knobs`.
  - Data types and basic constraints (UUID, date-time, etc.).
- **Business rules** (for example: minimum metric set per station, minimum number of snapshots per call, consistency of knob sets across segments) are enforced **outside** the JSON Schema, in application logic.

### 6.2 Partial / Missing Snapshots

The Optimizer must tolerate:

- Missing snapshots from some stations.  
- Missing optional fields (`segment`, `audio`, `constraints`, `targets`, `totals`).  
- Null values for metrics that are not available at a given time window.

Recommended behavior:

1. Validate each snapshot against the schema.  
2. If a snapshot is missing, treat that station as “no data” for that time slice; do **not** block optimization for the entire call.  
3. If metrics are partially missing, use only the available metrics; the model should support sparse feature vectors.  
4. Log and monitor missing data rates per station and per metric for quality assurance.

---

## 7. Evolution & Versioning

- When adding **new metrics**, simply start including them under `metrics` – no schema change needed.  
- When adding a **new station** (e.g. `STATION_12`), no schema change is required as long as `station_id` matches the `STATION_[0-9]+` pattern.  
- When adding new **top-level fields**, the schema **must** be updated (because `additionalProperties` is `false`).  
- `schema_version` is optional but recommended. Once adopted, the pipeline should:
  - Reject snapshots with unknown major versions.  
  - Log and gracefully degrade for unknown minor/patch versions if compatible.

---

## 8. Handoff to the Development Team

This document (Markdown + PDF) is intended to be:

- The **single source of truth** for Station Snapshot structure.  
- The reference for:
  - Gateway developers who emit snapshots.
  - Backend services that store and index snapshots.
  - The Optimizer service that consumes and analyzes them.
- The baseline for future iterations when additional hierarchy (segments, audio references, constraints, targets) is fully enabled in transport.

All future changes to the snapshot structure must update:

1. This specification document.  
2. The JSON Schema snippet in Section 5.  
3. The relevant encoder/decoder and validation code in the gateway and Optimizer services.
