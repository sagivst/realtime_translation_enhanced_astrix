<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Real-Time Translation System - Monitoring Dashboard v2.1</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 50%, #1a1a2e 100%);
            background-attachment: fixed;
            color: #e8eaed;
            overflow-x: hidden;
            line-height: 1.6;
            letter-spacing: 0.01em;
        }

        .header {
            background: linear-gradient(135deg, #5b6fd8 0%, #6b5b95 100%);
            padding: 28px 40px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 1.95em;
            margin-bottom: 6px;
            font-weight: 600;
            letter-spacing: -0.02em;
        }

        .header p {
            opacity: 0.92;
            font-size: 1.05em;
            font-weight: 400;
        }

        .status-badge {
            display: inline-block;
            padding: 7px 14px;
            border-radius: 16px;
            font-weight: 600;
            margin-top: 10px;
            font-size: 0.88em;
            letter-spacing: 0.02em;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            transition: all 0.2s ease;
        }

        .status-operational {
            background: linear-gradient(135deg, #51cf66, #40c057);
            color: white;
        }

        .status-degraded {
            background: linear-gradient(135deg, #ffd43b, #fcc419);
            color: #1a1a2e;
        }

        .status-down {
            background: linear-gradient(135deg, #ff6b6b, #fa5252);
            color: white;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: rgba(22, 33, 62, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.25), 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.08);
            transition: all 0.3s ease;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.3), 0 4px 12px rgba(0,0,0,0.15);
            border-color: rgba(255,255,255,0.12);
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 18px;
            padding-bottom: 14px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .card-title {
            font-size: 1.25em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 12px;
            letter-spacing: -0.01em;
        }

        .service-icon {
            width: 42px;
            height: 42px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            transition: transform 0.2s ease;
        }

        .service-icon:hover {
            transform: scale(1.05);
        }

        .icon-deepgram {
            background: #ff6b6b;
        }

        .icon-deepl {
            background: #4dabf7;
        }

        .icon-elevenlabs {
            background: #a78bfa;
        }

        .icon-hume {
            background: #51cf66;
        }

        .icon-system {
            background: #667eea;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 0;
            border-bottom: 1px solid rgba(255,255,255,0.06);
            transition: background 0.2s ease;
        }

        .metric-row:hover {
            background: rgba(255,255,255,0.02);
            padding-left: 8px;
            padding-right: 8px;
            margin-left: -8px;
            margin-right: -8px;
            border-radius: 6px;
        }

        .metric-row:last-child {
            border-bottom: none;
        }

        .metric-label {
            color: #9ca3af;
            font-size: 0.93em;
            font-weight: 500;
        }

        .metric-value {
            font-size: 1.35em;
            font-weight: 600;
            letter-spacing: -0.01em;
        }

        .metric-value.good {
            color: #51cf66;
        }

        .metric-value.warning {
            color: #fcc419;
        }

        .metric-value.critical {
            color: #ff6b6b;
        }

        .chart-container {
            position: relative;
            height: 200px;
            margin-top: 15px;
        }

        .large-chart {
            height: 300px;
        }

        .pipeline-viz {
            background: #0f1419;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .pipeline-step {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            padding: 10px;
            background: #16213e;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .pipeline-step.active {
            background: linear-gradient(90deg, #667eea, #764ba2);
            box-shadow: 0 0 20px rgba(102,126,234,0.5);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(102,126,234,0.5); }
            50% { box-shadow: 0 0 30px rgba(102,126,234,0.8); }
        }

        .pipeline-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8em;
            margin-right: 15px;
            background: #2a3f5f;
        }

        .pipeline-step.active .pipeline-icon {
            background: white;
            color: #667eea;
        }

        .pipeline-info {
            flex: 1;
        }

        .pipeline-name {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 3px;
        }

        .pipeline-latency {
            font-size: 0.9em;
            color: #aaa;
        }

        .pipeline-step.active .pipeline-latency {
            color: white;
            font-weight: bold;
        }

        .participants-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
        }

        .participant {
            display: flex;
            align-items: center;
            padding: 12px;
            background: #0f1419;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .participant-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
        }

        .participant-info {
            flex: 1;
        }

        .participant-name {
            font-weight: bold;
            margin-bottom: 3px;
        }

        .participant-lang {
            font-size: 0.85em;
            color: #aaa;
        }

        .participant-status {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #51cf66;
            box-shadow: 0 0 10px #51cf66;
        }

        .participant-status.speaking {
            background: #ff6b6b;
            box-shadow: 0 0 10px #ff6b6b;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .emotion-viz {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
        }

        .emotion-bar {
            margin-bottom: 15px;
        }

        .emotion-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .emotion-progress {
            height: 8px;
            background: #2a3f5f;
            border-radius: 10px;
            overflow: hidden;
        }

        .emotion-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.5s ease;
        }

        .latency-breakdown {
            width: 100%;
            max-height: none;
            overflow-y: visible;
            margin-top: 15px;
        }

        .latency-item {
            display: flex;
            align-items: center;
            margin-bottom: 0px;
            font-size: 0.62em;
            line-height: 1;
        }

        .latency-bar-container {
            flex: 1;
            height: 10px;
            background: rgba(15,20,25,0.8);
            border-radius: 4px;
            overflow: hidden;
            margin-left: 3px;
            position: relative;
            border: 1px solid rgba(255,255,255,0.05);
        }

        .latency-bar {
            height: 100%;
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            padding-left: 3px;
            font-weight: 600;
            font-size: 0.6em;
            box-shadow: inset 0 1px 2px rgba(255,255,255,0.2);
        }

        .latency-asr {
            background: #ff6b6b;
        }

        .latency-mt {
            background: #4dabf7;
        }

        .latency-tts {
            background: #a78bfa;
        }

        .latency-ls {
            background: #ffa94d;
        }

        .latency-hume {
            background: #51cf66;
        }

        .latency-network {
            background: #607D8B;
        }

        .network-latency-item {
            opacity: 0.8;
        }

        .pipeline-group {
            width: 100%;
            margin-bottom: 4px;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            overflow: visible;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .pipeline-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, rgba(26,26,46,0.9), rgba(20,20,36,0.95));
            padding: 6px 12px;
            font-weight: 600;
            color: #e8eaed;
            border-bottom: 1px solid rgba(255,255,255,0.08);
        }

        .pipeline-group-title {
            font-size: 0.75em;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .pipeline-group-total {
            font-size: 0.82em;
            font-weight: 700;
            color: #6ba3e8;
            background: rgba(107,163,232,0.15);
            padding: 3px 10px;
            border-radius: 8px;
        }

        .pipeline-group-content {
            padding: 4px 6px;
            background: rgba(15,15,30,0.7);
        }

        /* Bidirectional Bar for Latency Sync */
        .sync-bar-container {
            position: relative;
            width: 100%;
            height: 14px;
            background: #1a1a2e;
            border-radius: 2px;
            overflow: visible;
            display: flex;
            align-items: center;
        }

        .sync-bar-track {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
        }

        .sync-bar-negative-zone {
            flex: 1;
            background: linear-gradient(to right, #ff6b6b 0%, #1a1a2e 100%);
            opacity: 0.3;
        }

        .sync-bar-positive-zone {
            flex: 1;
            background: linear-gradient(to left, #51cf66 0%, #1a1a2e 100%);
            opacity: 0.3;
        }

        .sync-bar-center-line {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #666;
            z-index: 1;
        }

        .sync-bar-center-label {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.9em;
            color: #999;
            font-weight: 600;
            z-index: 2;
            pointer-events: none;
        }

        .sync-bar-fill {
            position: absolute;
            height: 100%;
            top: 0;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.85em;
            z-index: 3;
            border-radius: 4px;
        }

        .sync-bar-fill.positive {
            left: 50%;
            background: linear-gradient(to right, rgba(81, 207, 102, 0.5), rgba(81, 207, 102, 0.8));
            border: 1px solid #51cf66;
            color: #51cf66;
        }

        .sync-bar-fill.negative {
            right: 50%;
            background: linear-gradient(to left, rgba(255, 107, 107, 0.5), rgba(255, 107, 107, 0.8));
            border: 1px solid #ff6b6b;
            color: #ff6b6b;
        }

        .sync-bar-fill.zero {
            left: 50%;
            width: 40px !important;
            transform: translateX(-50%);
            background: #1a1a2e;
            border: 1px solid #666;
            color: #999;
        }

        .quota-card {
            background: #16213e;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .quota-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .quota-service {
            font-weight: bold;
        }

        .quota-percent {
            font-size: 1.2em;
        }

        .quota-bar {
            height: 6px;
            background: #2a3f5f;
            border-radius: 10px;
            overflow: hidden;
        }

        .quota-fill {
            height: 100%;
            transition: width 0.5s ease;
        }

        .quota-fill.low {
            background: #51cf66;
        }

        .quota-fill.medium {
            background: #fcc419;
        }

        .quota-fill.high {
            background: #ff6b6b;
        }

        .alert {
            background: #ff6b6b;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            animation: slideDown 0.5s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .alert-icon {
            font-size: 1.5em;
        }

        .controls {
            background: rgba(22,33,62,0.9);
            backdrop-filter: blur(10px);
            padding: 22px;
            border-radius: 14px;
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            border: 1px solid rgba(255,255,255,0.08);
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        }

        .btn {
            padding: 11px 22px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.25s ease;
            font-size: 0.93em;
            letter-spacing: 0.01em;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .btn-primary {
            background: linear-gradient(135deg, #5b6fd8 0%, #6b5b95 100%);
            color: white;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 24px rgba(91,111,216,0.35);
            background: linear-gradient(135deg, #6b7fe8 0%, #7b6ba5 100%);
        }

        .btn-secondary {
            background: rgba(42,63,95,0.8);
            color: #e8eaed;
            border: 1px solid rgba(255,255,255,0.08);
        }

        .btn-secondary:hover {
            background: rgba(58,95,143,0.9);
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
            color: #aaa;
        }

        .loading-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid #2a3f5f;
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .qa-dropdown {            background: #2a3f5f;            color: #eee;            border: 1px solid #3a5f8f;            padding: 8px 12px;            border-radius: 6px;            font-size: 0.95em;            cursor: pointer;            outline: none;            transition: all 0.3s ease;            min-width: 140px;        }
        .qa-dropdown:hover {            background: #3a5f8f;            border-color: #667eea;        }
        .qa-dropdown:focus {            border-color: #667eea;            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);        }

        .timestamp {
            color: #aaa;
            font-size: 0.85em;
            margin-top: 10px;
        }

        .badge {
            display: inline-block;
            padding: 5px 11px;
            border-radius: 14px;
            font-size: 0.73em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            box-shadow: 0 2px 6px rgba(0,0,0,0.12);
        }

        .badge-success {
            background: linear-gradient(135deg, #51cf66, #40c057);
            color: white;
        }

        .badge-warning {
            background: linear-gradient(135deg, #ffd43b, #fcc419);
            color: #1a1a2e;
        }

        .badge-error {
            background: linear-gradient(135deg, #ff6b6b, #fa5252);
            color: white;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        /* Live Transcription Window */
        .transcription-window {
            background: rgba(15,20,25,0.7);
            border-radius: 10px;
            padding: 16px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'SF Mono', 'Monaco', 'Cascadia Code', 'Courier New', monospace;
            font-size: 13.5px;
            line-height: 1.65;
            scroll-behavior: smooth;
            border: 1px solid rgba(255,255,255,0.08);
        }

        .transcription-window::-webkit-scrollbar {
            width: 10px;
        }

        .transcription-window::-webkit-scrollbar-track {
            background: rgba(22,33,62,0.5);
            border-radius: 5px;
            margin: 4px;
        }

        .transcription-window::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #5b6fd8, #6b5b95);
            border-radius: 5px;
            border: 2px solid rgba(22,33,62,0.5);
        }

        .transcription-window::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #6b7fe8, #7b6ba5);
        }

        .transcript-line {
            margin-bottom: 10px;
            padding: 10px 14px;
            border-radius: 8px;
            background: rgba(22,33,62,0.7);
            border-left: 3px solid transparent;
            animation: fadeIn 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            transition: all 0.2s ease;
        }

        .transcript-line:hover {
            background: rgba(22,33,62,0.9);
            transform: translateX(2px);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(12px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .transcript-line.partial {
            border-left-color: #ffc107;
            opacity: 0.75;
        }

        .transcript-line.final {
            border-left-color: #51cf66;
        }

        .transcript-timestamp {
            color: #667eea;
            font-weight: bold;
            margin-right: 10px;
        }

        .transcript-type {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            margin-right: 10px;
        }

        .transcript-type.partial {
            background: #fcc419;
            color: #000;
        }

        .transcript-type.final {
            background: #51cf66;
            color: white;
        }

        .transcript-text {
            color: #eee;
        }

        .transcript-empty {
            color: #aaa;
            text-align: center;
            padding: 40px;
            font-size: 16px;
        }

        .transcription-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .toggle-scroll {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background: #667eea;
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s ease;
        }

        .toggle-scroll:hover {
            background: #764ba2;
        }

        .toggle-scroll.disabled {
            background: #ff6b6b;
        }

        /* Audio Stream Components */
        .audio-player-container {
            background: #0f1419;
            border-radius: 8px;
            padding: 20px;
            margin-top: 15px;
        }

        .audio-visualizer {
            height: 120px;
            background: #000;
            border-radius: 8px;
            margin-bottom: 15px;
            position: relative;
            overflow: hidden;
        }

        .audio-visualizer canvas {
            width: 100%;
            height: 100%;
        }

        .audio-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
        }

        .audio-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: #16213e;
            border-radius: 6px;
            flex: 1;
        }

        .audio-status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #666;
        }

        .audio-status-indicator.active {
            background: #51cf66;
            box-shadow: 0 0 10px #51cf66;
            animation: pulse-audio 1.5s infinite;
        }

        @keyframes pulse-audio {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .volume-slider {
            width: 120px;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #2a3f5f;
            outline: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        /* Recording List */
        .recording-list {
            margin-top: 15px;
            
            overflow-y: auto;
        }

        .recording-item {
            background: #16213e;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
            transition: all 0.3s ease;
        }

        .recording-item:hover {
            background: #1f2d4a;
            transform: translateX(5px);
        }

        .recording-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
        }

        .recording-info {
            flex: 1;
        }

        .recording-title {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .recording-meta {
            font-size: 0.85em;
            color: #aaa;
        }

        .recording-actions {
            display: flex;
            gap: 10px;
        }

        .btn-icon {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: #667eea;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.2s ease;
        }

        .btn-icon:hover {
            background: #764ba2;
            transform: scale(1.1);
        }

        .btn-icon.delete {
            background: #ff6b6b;
        }

        .btn-icon.delete:hover {
            background: #ff5252;
        }

        .waveform-container {
            height: 60px;
            background: #000;
            border-radius: 4px;
            margin-top: 10px;
            position: relative;
        }

        .call-info-box {
            background: #0f1419;
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .call-info-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #2a3f5f;
        }

        .call-info-row:last-child {
            border-bottom: none;
        }

        .call-info-label {
            color: #aaa;
        }

        .call-info-value {
            color: #eee;
            font-weight: bold;
        }

        /* Toggle Switch for Comfort Noise */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #dc3545;
            transition: 0.4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #51cf66;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        /* Hume AI Emotion Visualization Styles */
        .emotion-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            padding: 15px;
        }

        .emotion-plot {
            position: relative;
        }

        .plot-labels {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .plot-labels span {
            position: absolute;
            font-size: 11px;
            color: #6b7280;
            font-weight: 600;
        }

        .label-top {
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
        }

        .label-right {
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
        }

        .label-bottom {
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
        }

        .label-left {
            left: 5px;
            top: 50%;
            transform: translateY(-50%);
        }

        .emotions-list, .prosody-metrics {
            background: #f9fafb;
            border-radius: 8px;
            padding: 15px;
        }

        .emotions-list h4, .prosody-metrics h4 {
            margin: 0 0 12px 0;
            font-size: 13px;
            color: #374151;
            font-weight: 600;
        }

        #emotionBars .emotion-bar {
            margin-bottom: 10px;
        }

        .emotion-bar-label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-bottom: 4px;
            color: #374151;
        }

        .emotion-bar-fill {
            height: 20px;
            background: linear-gradient(90deg, #f59e0b, #fbbf24);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .prosody-metrics .metric {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e5e7eb;
        }

        .metric:last-child {
            border-bottom: none;
        }

        .metric-label {
            font-size: 12px;
            color: #6b7280;
        }

        .metric-value {
            font-size: 12px;
            font-weight: 600;
            color: #111827;
        }

    </style>
</head>
<body>
    <div class="header">
        <h1>üéØ Real-Time Translation Monitoring Dashboard</h1>
        <p>Live system metrics and third-party service monitoring</p>
        <span class="status-badge status-operational" id="systemStatus">‚ö° System Operational</span>
    </div>

    <div class="container">
        <div id="alerts"></div>

        <div class="controls">
            <button class="btn btn-primary" onclick="refreshDashboard()">üîÑ Refresh Data</button>
            <button class="btn btn-secondary" onclick="toggleAutoRefresh()">
                <span id="autoRefreshBtn">‚è∏Ô∏è Pause Auto-Refresh</span>
            </button>
            <button class="btn btn-secondary" onclick="exportMetrics()">üìä Export Metrics</button>
            <button class="btn btn-secondary" onclick="window.open('/hmlcp-demo.html', '_blank')">üìñ View System Flow</button>
        </div>

        <div class="grid">

            <!-- Deepgram Service -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <div class="service-icon icon-deepgram">üéôÔ∏è</div>
                        <div>
                            <div>Deepgram (ASR)</div>
                            <div style="font-size: 0.7em; color: #aaa;">Speech Recognition</div>
                        </div>
                    </div>
                    <span class="status-badge status-operational" id="deepgramStatus">‚úì OK</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Entry Point</span>
                    <span class="metric-value" style="font-size: 0.8em;">asr-streaming-worker:178</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Latency (p95)</span>
                    <span class="metric-value" id="deepgramLatency">- ms</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Requests/min</span>
                    <span class="metric-value" id="deepgramRequests">45</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Error Rate</span>
                    <span class="metric-value good" id="deepgramErrors">0.5%</span>
                </div>
                <div class="chart-container">
                    <canvas id="deepgramChart"></canvas>
                </div>
            </div>

            <!-- DeepL Service -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <div class="service-icon icon-deepl">üåê</div>
                        <div>
                            <div>DeepL (MT)</div>
                            <div style="font-size: 0.7em; color: #aaa;">Machine Translation</div>
                        </div>
                    </div>
                    <span class="status-badge status-operational" id="deeplStatus">‚úì OK</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Entry Point</span>
                    <span class="metric-value" style="font-size: 0.8em;">deepl-incremental-mt:245</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Latency (p95)</span>
                    <span class="metric-value" id="deeplLatency">- ms</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Cache Hit Rate</span>
                    <span class="metric-value good" id="deeplCacheHit">65%</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Error Rate</span>
                    <span class="metric-value good" id="deeplErrors">0.2%</span>
                </div>
                <div class="chart-container">
                    <canvas id="deeplChart"></canvas>
                </div>
            </div>

            <!-- ElevenLabs Service -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <div class="service-icon icon-elevenlabs">üó£Ô∏è</div>
                        <div>
                            <div>ElevenLabs (TTS)</div>
                            <div style="font-size: 0.7em; color: #aaa;">Text-to-Speech</div>
                        </div>
                    </div>
                    <span class="status-badge status-operational" id="elevenlabsStatus">‚úì OK</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Entry Point</span>
                    <span class="metric-value" style="font-size: 0.8em;">elevenlabs-tts-service:215</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Latency (p95)</span>
                    <span class="metric-value" id="elevenlabsLatency">- ms</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Requests/min</span>
                    <span class="metric-value" id="elevenlabsRequests">40</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Error Rate</span>
                    <span class="metric-value good" id="elevenlabsErrors">0.8%</span>
                </div>
                <div class="chart-container">
                    <canvas id="elevenlabsChart"></canvas>
                </div>
            </div>

            <!-- Hume AI Service -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <div class="service-icon icon-hume">üòä</div>
                        <div>
                            <div>Hume AI (EVI)</div>
                            <div style="font-size: 0.7em; color: #aaa;">Emotion Analysis</div>
                        </div>
                    </div>
                    <span class="status-badge status-operational" id="humeStatus">‚úì OK</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Entry Point</span>
                    <span class="metric-value" style="font-size: 0.8em;">hume-evi-adapter:165</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Latency (p95)</span>
                    <span class="metric-value" id="humeLatency">- ms</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Requests/min</span>
                    <span class="metric-value" id="humeRequests">60</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Error Rate</span>
                    <span class="metric-value good" id="humeErrors">0.3%</span>
                </div>
                <div class="chart-container">

                    <canvas id="humeChart"></canvas>
                </div>
            </div>
            <!-- QA Settings Card -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <div class="service-icon icon-system">‚öôÔ∏è</div>
                        <div>
                            <div>QA Settings</div>
                            <div style="font-size: 0.7em; color: #aaa;">Translation Configuration</div>
                        </div>
                    </div>
                    <span class="status-badge status-operational" id="qaStatus">‚úì Active</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Source Language</span>
                    <div style="flex: 1; text-align: right;">
                        <select id="qaSourceLang" class="qa-dropdown" onchange="updateQASettings()">
                            <option value="en" selected>English</option>
                            <option value="ja">Japanese</option>
                            <option value="es">Spanish</option>
                            <option value="fr">French</option>
                            <option value="de">German</option>
                            <option value="it">Italian</option>
                            <option value="pt">Portuguese</option>
                            <option value="ko">Korean</option>
                            <option value="zh">Chinese</option>
                            <option value="ru">Russian</option>
                        </select>
                    </div>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Target Language</span>
                    <div style="flex: 1; text-align: right;">
                        <select id="qaTargetLang" class="qa-dropdown" onchange="updateQASettings()">
                            <option value="en" selected>English</option>
                            <option value="ja">Japanese</option>
                            <option value="es">Spanish</option>
                            <option value="fr">French</option>
                            <option value="de">German</option>
                            <option value="it">Italian</option>
                            <option value="pt">Portuguese</option>
                            <option value="ko">Korean</option>
                            <option value="zh">Chinese</option>
                            <option value="ru">Russian</option>
                        </select>
                    </div>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Translation Mode</span>
                    <span class="metric-value" id="qaTranslationMode" style="font-size: 0.9em; color: #fcc419;">‚ö†Ô∏è QA Mode (No Translation)</span>
                </div>
                <div style="margin-top: 15px; padding: 12px; background: #0f1419; border-radius: 8px; font-size: 0.85em; color: #aaa;">
                    <strong style="color: #fcc419;">‚ÑπÔ∏è QA Mode:</strong> When source and target are the same, DeepL translation is bypassed for testing purposes.
                </div>
            </div>
        </div>


            <!-- Comfort Noise Control Card -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <div class="service-icon" style="background: #667eea;">üîä</div>
                        <div>
                            <div>Comfort Noise & Sync</div>
                            <div style="font-size: 0.7em; color: #aaa;">Audio Stream Buffer Control</div>
                        </div>
                    </div>
                    <span class="status-badge" id="comfortNoiseStatus" style="background: #dc3545;">‚úó Disabled</span>
                </div>

                <!-- Enable/Disable Toggle -->
                <div class="metric-row">
                    <span class="metric-label">Comfort Noise</span>
                    <div style="flex: 1; text-align: right;">
                        <label class="switch">
                            <input type="checkbox" id="comfortNoiseEnabled" onchange="updateComfortNoiseConfig()">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>

                <!-- Noise Type -->
                <div class="metric-row">
                    <span class="metric-label">Noise Type</span>
                    <div style="flex: 1; text-align: right;">
                        <select id="comfortNoiseType" class="qa-dropdown" onchange="updateComfortNoiseConfig()">
                            <option value="pink" selected>Pink Noise</option>
                            <option value="brown">Brown Noise</option>
                        </select>
                    </div>
                </div>

                <!-- Speech Level -->
                <div class="metric-row">
                    <span class="metric-label">Speech Level</span>
                    <div style="flex: 1; display: flex; align-items: center; gap: 10px;">
                        <input type="range" id="comfortSpeechLevel" min="-60" max="-10" value="-30" step="1"
                               style="flex: 1;" oninput="updateComfortNoiseConfig()">
                        <span id="comfortSpeechLevelValue" style="min-width: 50px; text-align: right; color: #51cf66;">-30 dB</span>
                    </div>
                </div>

                <!-- Silence Level -->
                <div class="metric-row">
                    <span class="metric-label">Silence Level</span>
                    <div style="flex: 1; display: flex; align-items: center; gap: 10px;">
                        <input type="range" id="comfortSilenceLevel" min="-40" max="0" value="-15" step="1"
                               style="flex: 1;" oninput="updateComfortNoiseConfig()">
                        <span id="comfortSilenceLevelValue" style="min-width: 50px; text-align: right; color: #fcc419;">-15 dB</span>
                    </div>
                </div>

                <!-- Fade Duration -->
                <div class="metric-row">
                    <span class="metric-label">Fade Duration</span>
                    <div style="flex: 1; display: flex; align-items: center; gap: 10px;">
                        <input type="range" id="comfortFadeDuration" min="10" max="200" value="50" step="10"
                               style="flex: 1;" oninput="updateComfortNoiseConfig()">
                        <span id="comfortFadeDurationValue" style="min-width: 50px; text-align: right; color: #74c0fc;">50 ms</span>
                    </div>
                </div>

                <!-- Buffer Delay (Manual, until Dispatcher is ready) -->
                <div class="metric-row">
                    <span class="metric-label">Buffer Delay</span>
                    <div style="flex: 1; display: flex; align-items: center; gap: 10px;">
                        <input type="range" id="comfortBufferDelay" min="0" max="2000" value="0" step="50"
                               style="flex: 1;" oninput="updateComfortNoiseConfig()">
                        <span id="comfortBufferDelayValue" style="min-width: 50px; text-align: right; color: #a78bfa;">0 ms</span>
                    </div>
                </div>

                <!-- VAD Threshold -->
                <div class="metric-row">
                    <span class="metric-label">VAD Threshold</span>
                    <div style="flex: 1; display: flex; align-items: center; gap: 10px;">
                        <input type="range" id="comfortVadThreshold" min="0.001" max="0.1" value="0.01" step="0.001"
                               style="flex: 1;" oninput="updateComfortNoiseConfig()">
                        <span id="comfortVadThresholdValue" style="min-width: 50px; text-align: right; color: #ff6b6b;">0.010</span>
                    </div>
                </div>

                <!-- Info Box -->
                <div style="margin-top: 15px; padding: 12px; background: #0f1419; border-radius: 8px; font-size: 0.85em; color: #aaa;">
                    <strong style="color: #667eea;">‚ÑπÔ∏è About:</strong> Comfort noise fills audio gaps with smooth fading.
                    Buffer delay syncs channels (controlled by future Dispatcher). VAD detects speech presence.
                </div>
            </div>

        <!-- AUDIO PIPELINE SECTION -->
        <h2 style="color: #667eea; margin: 30px 0 20px 0; font-size: 1.5em;">üì° Live Audio Pipeline</h2>

        <div class="grid">
            <!-- 1. Asterisk Incoming Voice Stream -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <div class="service-icon" style="background: #ff6b6b;">üìû</div>
                        <span>1. Asterisk Voice Stream (IN)</span>
                    </div>
                    <span class="status-badge" id="asteriskStreamStatus">‚è∏ Idle</span>
                </div>

                <!-- Extension Monitor - Live Packet Flow -->
                <div style="background: rgba(102, 126, 234, 0.1); border: 2px solid #667eea; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                    <div style="font-size: 0.9em; color: #667eea; font-weight: bold; margin-bottom: 10px; display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 1.5em;">üì°</span>
                        Extension Monitor - Live Packet Flow
                    </div>
                    <div class="metric-row" style="border-bottom: 1px solid #667eea; padding-bottom: 10px; margin-bottom: 10px;">
                        <span class="metric-label" style="font-size: 0.95em;">Extension Number</span>
                        <span class="metric-value" id="extensionNumber" style="font-size: 1.5em; color: #667eea; font-weight: bold;">---</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Call UUID</span>
                        <span class="metric-value" id="callUuid" style="font-size: 0.75em; font-family: monospace; color: #51cf66;">Waiting...</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Packets Received</span>
                        <span class="metric-value" id="packetCount" style="color: #fcc419;">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Last Update</span>
                        <span class="metric-value" id="lastPacketTime" style="font-size: 0.75em; color: #aaa;">Never</span>
                    </div>
                    <div style="margin-top: 10px; padding: 8px; background: rgba(102, 126, 234, 0.2); border-radius: 6px; text-align: center; font-size: 0.85em;">
                        <div id="extensionBadge" style="font-size: 1.2em; font-weight: bold; color: #667eea;">
                            WAITING FOR PACKETS...
                        </div>
                    </div>
                </div>

                <div class="call-info-box" id="callInfo" style="display:none;">
                    <div class="call-info-row">
                        <span class="call-info-label">Call UUID:</span>
                        <span class="call-info-value" id="callUUID">-</span>
                    </div>
                    <div class="call-info-row">
                        <span class="call-info-label">Duration:</span>
                        <span class="call-info-value" id="callDuration">0:00</span>
                    </div>
                    <div class="call-info-row">
                        <span class="call-info-label">Sample Rate:</span>
                        <span class="call-info-value">8kHz 16-bit PCM</span>
                    </div>
                </div>

                <div class="audio-player-container">
                    <div class="audio-visualizer">
                        <canvas id="incomingAudioViz" width="800" height="120"></canvas>
                    </div>
                    <div class="audio-status">
                        <div class="audio-status-indicator" id="incomingAudioIndicator"></div>
                        <span id="incomingAudioStatus">No active call</span>
                    </div>
                    <div class="audio-controls">
                        <div class="volume-control">
                            <span>üîä</span>
                            <input type="range" class="volume-slider" id="incomingVolume" min="0" max="100" value="0">
                            <span id="incomingVolumeLabel">0%</span>
                        </div>
                    </div>
                    <audio id="incomingAudioPlayer" autoplay style="display:none;"></audio>
                </div>
        </div>

            <!-- 2. Deepgram Transcription (STT) -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <div class="service-icon" style="background: #667eea;">üéôÔ∏è</div>
                        <span>2. Deepgram Transcription (STT)</span>
                    </div>
                    <span class="status-badge" id="deepgramStatus">‚è∏ Idle</span>
                </div>

                <div style="padding: 15px; background: #0f1419; border-radius: 6px; margin-top: 10px;">
                    <div style="margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div style="color: #aaa; font-size: 0.85em;">üìù Live Transcription (LIFO):</div>
                            <button class="btn btn-secondary" onclick="clearTranscripts()" style="font-size: 0.8em; padding: 4px 8px;">üóëÔ∏è Clear</button>
                        </div>
                        <div class="transcription-window" id="transcriptionWindow" style="padding: 10px; background: #1a2332; border-radius: 4px; height: 150px; max-height: 150px; overflow-y: auto; border-left: 3px solid #667eea; font-family: monospace;">
                            <div class="transcript-empty" id="transcriptEmpty" style="color: #666; text-align: center; padding: 20px;">
                                üé§ Waiting for transcriptions...
                            </div>
                        </div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 15px; padding-top: 15px; border-top: 1px solid #2a3f5f;">
                        <div>
                            <div style="color: #aaa; font-size: 0.8em;">Transcriptions:</div>
                            <div id="deepgramTranscriptCount" style="color: #667eea; font-weight: bold; margin-top: 3px;">0</div>
                        </div>
                        <div>
                            <div style="color: #aaa; font-size: 0.8em;">Avg Latency:</div>
                            <div id="deepgramAvgLatency" style="color: #10b981; font-weight: bold; margin-top: 3px;">- ms</div>
                        </div>
                        <div>
                            <div style="color: #aaa; font-size: 0.8em;">Language:</div>
                            <div id="deepgramLanguage" style="color: #a78bfa; font-weight: bold; margin-top: 3px;">en-US</div>
                        </div>
                    </div>
                </div>

                <div style="margin-top: 10px; padding: 10px; background: rgba(102, 126, 234, 0.1); border-radius: 4px; border-left: 3px solid #667eea;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div id="deepgramActivityIndicator" style="width: 8px; height: 8px; border-radius: 50%; background: #666;"></div>
                        <span id="deepgramActivityText" style="color: #aaa; font-size: 0.9em;">Waiting for audio...</span>
                    </div>
                </div>
            </div>

            <!-- 3. DeepL Translation -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <div class="service-icon" style="background: #10b981;">üîÑ</div>
                        <span>3. DeepL Translation</span>
                    </div>
                    <span class="status-badge" id="deeplStatus">‚è∏ Idle</span>
                </div>

                <div style="padding: 15px; background: #0f1419; border-radius: 6px; margin-top: 10px;">
                    <div style="margin-bottom: 15px;">
                        <div style="color: #aaa; font-size: 0.85em; margin-bottom: 5px;">üìù Original ‚Üí üåê Translated:</div>
                        <div id="deeplTranslationWindow" style="padding: 10px; background: #1a2332; border-radius: 4px; color: #e0e0e0; height: 150px; max-height: 150px; overflow-y: auto; font-family: monospace; border-left: 3px solid #667eea;">
                            <div class="translation-empty" style="color: #666; text-align: center; padding: 20px;">Waiting for translations...</div>
                        </div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; padding-top: 15px; border-top: 1px solid #2a3f5f;">
                        <div>
                            <div style="color: #aaa; font-size: 0.8em;">Language Pair:</div>
                            <div id="deeplLanguagePair" style="color: #10b981; font-weight: bold; margin-top: 3px;">en ‚Üí ja</div>
                        </div>
                        <div>
                            <div style="color: #aaa; font-size: 0.8em;">Translation Time:</div>
                            <div id="deeplTranslationTime" style="color: #667eea; font-weight: bold; margin-top: 3px;">- ms</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 4. ElevenLabs (Text to Voice) -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <div class="service-icon" style="background: #a78bfa;">üéôÔ∏è</div>
                        <span>4. ElevenLabs (Text to Voice)</span>
                    </div>
                    <span class="status-badge" id="translatedStreamStatus">‚è∏ Idle</span>
                </div>

                <div class="audio-player-container">
                    <div class="audio-visualizer">
                        <canvas id="outgoingAudioViz" width="800" height="120"></canvas>
                    </div>
                    <div class="audio-status">
                        <div class="audio-status-indicator" id="outgoingAudioIndicator"></div>
                        <span id="outgoingAudioStatus">Waiting for translation</span>
                    </div>
                    <div class="audio-controls">
                        <div class="volume-control">
                            <span>üîä</span>
                            <input type="range" class="volume-slider" id="outgoingVolume" min="0" max="100" value="0">
                            <span id="outgoingVolumeLabel">0%</span>
                        </div>
                    </div>
                    <audio id="outgoingAudioPlayer" autoplay style="display:none;"></audio>
                </div>

                <div style="padding: 15px; background: #0f1419; border-radius: 6px; margin-top: 10px;">
                    <div style="margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <div style="color: #aaa; font-size: 0.85em;">üåê Translated Text (LIFO):</div>
                                <div id="ttsEmotionBadge" style="display: inline-block; padding: 4px 10px; border-radius: 12px; font-size: 0.75em; font-weight: bold; background: #444; color: #888;">
                                    üòê Neutral
                                </div>
                                <div id="humeServiceStatus" style="display: inline-flex; align-items: center; gap: 5px; padding: 3px 8px; border-radius: 10px; font-size: 0.7em; background: #1a1a1a; border: 1px solid #333;">
                                    <div id="humeServicePulse" style="width: 6px; height: 6px; border-radius: 50%; background: #666;"></div>
                                    <span id="humeServiceText" style="color: #666;">Hume: Waiting</span>
                                </div>
                            </div>
                            <button class="btn btn-secondary" onclick="clearTranslations()" style="font-size: 0.8em; padding: 4px 8px;">üóëÔ∏è Clear</button>
                        </div>
                        <div class="translation-window" id="translationWindow" style="padding: 10px; background: #1a2332; border-radius: 4px; height: 150px; max-height: 150px; overflow-y: auto; border-left: 3px solid #a78bfa; font-family: monospace;">
                            <div class="translation-empty" id="translationEmpty" style="color: #666; text-align: center; padding: 20px;">
                                üéôÔ∏è Waiting for translations...
                            </div>
                        </div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 15px; padding-top: 15px; border-top: 1px solid #2a3f5f;">
                        <div>
                            <div style="color: #aaa; font-size: 0.8em;">Translations:</div>
                            <div id="elevenlabsTranslationCount" style="color: #a78bfa; font-weight: bold; margin-top: 3px;">0</div>
                        </div>
                        <div>
                            <div style="color: #aaa; font-size: 0.8em;">Avg Latency:</div>
                            <div id="elevenlabsAvgLatency" style="color: #10b981; font-weight: bold; margin-top: 3px;">- ms</div>
                        </div>
                        <div>
                            <div style="color: #aaa; font-size: 0.8em;">Languages:</div>
                            <div id="elevenlabsLanguages" style="color: #a78bfa; font-weight: bold; margin-top: 3px;">en ‚Üí ja</div>
                        </div>
                    </div>
                </div>

                <div style="margin-top: 15px; padding: 12px; background: #0f1419; border-radius: 6px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <span style="color: #aaa; font-size: 0.9em;">Translation Pipeline:</span>
                        <span id="translationLanguage" style="color: #667eea; font-weight: bold;">en ‚Üí es</span>
                    </div>
                    <div style="display: flex; gap: 5px;">
                        <div style="flex: 1; height: 4px; background: #51cf66; border-radius: 2px;" title="ASR"></div>
                        <div style="flex: 1; height: 4px; background: #4dabf7; border-radius: 2px;" title="MT"></div>
                        <div style="flex: 1; height: 4px; background: #a78bfa; border-radius: 2px;" title="TTS"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.75em; color: #aaa;">
                        <span>ASR</span>
                        <span>MT</span>
                        <span>TTS</span>
                    </div>
                </div>
            </div>

            <!-- 5. Hume AI (Emotion/Prosody Analysis) -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <div class="service-icon" style="background: #f59e0b;">üé≠</div>
                        <span>5. Hume AI (Emotion/Prosody)</span>
                    </div>
                    <span class="status-badge" id="humeStatus">‚è∏ Idle</span>
                </div>

                <div class="emotion-container">
                    <!-- Valence/Arousal 2D Plot -->
                    <div class="emotion-plot">
                        <canvas id="emotionPlot" width="300" height="300"></canvas>
                        <div class="plot-labels">
                            <span class="label-top">Excited</span>
                            <span class="label-right">Positive</span>
                            <span class="label-bottom">Calm</span>
                            <span class="label-left">Negative</span>
                        </div>
                    </div>

                    <!-- Top 3 Emotions -->
                    <div class="emotions-list">
                        <h4>Top Emotions</h4>
                        <div id="emotionBars"></div>
                    </div>

                    <!-- Prosody Metrics -->
                    <div class="prosody-metrics">
                        <h4>Voice Characteristics</h4>
                        <div class="metric">
                            <span class="metric-label">Pitch:</span>
                            <span class="metric-value" id="pitchValue">--</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Energy:</span>
                            <span class="metric-value" id="energyValue">--</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">Speaking Rate:</span>
                            <span class="metric-value" id="rateValue">--</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 6. Asterisk Outbound Voice Stream -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <div class="service-icon" style="background: #5b6fd8;">üì§</div>
                        <span>6. Asterisk Voice Stream (OUT)</span>
                    </div>
                    <span class="status-badge" id="asteriskOutboundStreamStatus">‚è∏ Idle</span>
                </div>

                <!-- Extension Monitor - Outbound Stream -->
                <div style="background: rgba(91, 111, 216, 0.1); border: 2px solid #5b6fd8; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                    <div style="font-size: 0.9em; color: #5b6fd8; font-weight: bold; margin-bottom: 10px; display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 1.5em;">üì°</span>
                        Bridge ‚Üí Asterisk - Live Packet Flow
                    </div>
                    <div class="metric-row" style="border-bottom: 1px solid #5b6fd8; padding-bottom: 10px; margin-bottom: 10px;">
                        <span class="metric-label" style="font-size: 0.95em;">Extension Number</span>
                        <span class="metric-value" id="outboundExtensionNumber" style="font-size: 1.5em; color: #5b6fd8; font-weight: bold;">---</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Bridge ID</span>
                        <span class="metric-value" id="outboundBridgeId" style="font-size: 0.65em; font-family: monospace; color: #51cf66;">Waiting...</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Call UUID</span>
                        <span class="metric-value" id="outboundCallUuid" style="font-size: 0.75em; font-family: monospace; color: #51cf66;">Waiting...</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Packets Sent</span>
                        <span class="metric-value" id="outboundPacketCount" style="color: #fcc419;">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Last Update</span>
                        <span class="metric-value" id="outboundLastPacketTime" style="font-size: 0.75em; color: #aaa;">Never</span>
                    </div>
                    <div style="margin-top: 10px; padding: 8px; background: rgba(91, 111, 216, 0.2); border-radius: 6px; text-align: center; font-size: 0.85em;">
                        <div id="outboundExtensionBadge" style="font-size: 1.2em; font-weight: bold; color: #5b6fd8;">
                            WAITING FOR OUTBOUND PACKETS...
                        </div>
                    </div>
                </div>

                <div class="audio-player-container">
                    <div class="audio-visualizer">
                        <canvas id="asteriskOutboundViz" width="800" height="120"></canvas>
                    </div>
                    <div class="audio-status">
                        <div class="audio-status-indicator" id="asteriskOutboundIndicator"></div>
                        <span id="asteriskOutboundStatus">No active call</span>
                    </div>
                    <div class="audio-controls">
                        <div class="volume-control">
                            <span>üîä</span>
                            <input type="range" class="volume-slider" id="asteriskOutboundVolume" min="0" max="100" value="0">
                            <span id="asteriskOutboundVolumeLabel">0%</span>
                        </div>
                    </div>
                    <audio id="asteriskOutboundPlayer" autoplay style="display:none;"></audio>
                </div>
            </div>

            <!-- Call Recordings -->
            <div class="card full-width">
                <div class="card-header">
                    <div class="card-title">
                        <div class="service-icon" style="background: #51cf66;">üíæ</div>
                        <span>4. Call Recordings</span>
                    </div>
                    <button class="btn btn-secondary" onclick="refreshRecordings()">üîÑ Refresh</button>
                </div>

                <div class="recording-list" id="recordingList">
                    <div class="transcript-empty">
                        üìÅ No recordings yet. Call recordings will appear here automatically.
                    </div>
                </div>
            </div>
        </div>

        
            <div class="transcription-window" id="transcriptionWindow">
                <div class="transcript-empty">
                    üé§ Waiting for transcriptions... Call extension 7777 to start.
                </div>
            </div>
        </div>

        <!-- End-to-End Latency -->
        <div class="card full-width">
            <div class="card-header">
                <div class="card-title">
                    <div class="service-icon icon-system">‚ö°</div>
                    <span>End-to-End Translation Latency</span>
                </div>
                <span class="metric-value" id="e2eLatency">- ms</span>
            </div>
            <div class="latency-breakdown">
                <!-- Serial Pipeline Group -->
                <div class="pipeline-group">
                    <div class="pipeline-group-header">
                        <span class="pipeline-group-title">Serial</span>
                        <span class="pipeline-group-total" id="serialTotal">- ms</span>
                    </div>
                    <div class="pipeline-group-content">
                        <div class="latency-item network-latency-item">
                            <span style="width: 140px; font-size: 0.85em; color: #999;">‚Üì Server (AudioSocket‚ÜíASR)</span>
                            <div class="latency-bar-container">
                                <div class="latency-bar latency-network" id="latencyBarAudioSocketAsr" style="width: 0%;">-</div>
                            </div>
                        </div>
                        <div class="latency-item">
                            <span style="width: 140px;">ASR (Deepgram)</span>
                            <div class="latency-bar-container">
                                <div class="latency-bar latency-asr" id="latencyBarAsr" style="width: 0%;">-</div>
                            </div>
                        </div>
                        <div class="latency-item network-latency-item">
                            <span style="width: 140px; font-size: 0.85em; color: #999;">‚Üì Server (ASR‚ÜíMT)</span>
                            <div class="latency-bar-container">
                                <div class="latency-bar latency-network" id="latencyBarAsrMt" style="width: 0%;">-</div>
                            </div>
                        </div>
                        <div class="latency-item">
                            <span style="width: 140px;">MT (DeepL)</span>
                            <div class="latency-bar-container">
                                <div class="latency-bar latency-mt" id="latencyBarMt" style="width: 0%;">-</div>
                            </div>
                        </div>
                        <div class="latency-item network-latency-item">
                            <span style="width: 140px; font-size: 0.85em; color: #999;">‚Üì Server (MT‚ÜíTTS)</span>
                            <div class="latency-bar-container">
                                <div class="latency-bar latency-network" id="latencyBarMtTts" style="width: 0%;">-</div>
                            </div>
                        </div>
                        <div class="latency-item">
                            <span style="width: 140px;">TTS (ElevenLabs)</span>
                            <div class="latency-bar-container">
                                <div class="latency-bar latency-tts" id="latencyBarTts" style="width: 0%;">-</div>
                            </div>
                        </div>
                        <div class="latency-item network-latency-item">
                            <span style="width: 140px; font-size: 0.85em; color: #999;">‚Üì Server (TTS‚ÜíLS)</span>
                            <div class="latency-bar-container">
                                <div class="latency-bar latency-network" id="latencyBarTtsLs" style="width: 0%;">-</div>
                            </div>
                        </div>
                        <div class="latency-item">
                            <span style="width: 140px;">LS (Latency Sync)</span>
                            <div class="latency-bar-container">
                                <div class="latency-bar latency-ls" id="latencyBarLs" style="width: 0%;">-</div>
                            </div>
                        </div>
                        <div class="latency-item network-latency-item">
                            <span style="width: 140px; font-size: 0.85em; color: #999;">‚Üì Server (LS‚ÜíBridge)</span>
                            <div class="latency-bar-container">
                                <div class="latency-bar latency-network" id="latencyBarLsBridge" style="width: 0%;">-</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Parallel Pipeline Group -->
                <div class="pipeline-group">
                    <div class="pipeline-group-header">
                        <span class="pipeline-group-title">Parallel</span>
                        <span class="pipeline-group-total" id="parallelTotal">- ms</span>
                    </div>
                    <div class="pipeline-group-content">
                        <div class="latency-item network-latency-item">
                            <span style="width: 140px; font-size: 0.85em; color: #999;">‚Üì Server (AudioSocket‚ÜíEV)</span>
                            <div class="latency-bar-container">
                                <div class="latency-bar latency-network" id="latencyBarAudioSocketEv" style="width: 0%;">-</div>
                            </div>
                        </div>
                        <div class="latency-item">
                            <span style="width: 140px;">EV (Hume)</span>
                            <div class="latency-bar-container">
                                <div class="latency-bar latency-hume" id="latencyBarHume" style="width: 0%;">-</div>
                            </div>
                        </div>
                        <div class="latency-item network-latency-item">
                            <span style="width: 140px; font-size: 0.85em; color: #999;">‚Üì Server (EV‚ÜíTTS)</span>
                            <div class="latency-bar-container">
                                <div class="latency-bar latency-network" id="latencyBarEvTts" style="width: 0%;">-</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Latency Sync Group -->
                <div class="pipeline-group">
                    <div class="pipeline-group-header">
                        <span class="pipeline-group-title">Latency Sync</span>
                        <span class="pipeline-group-total">[total MS]</span>
                    </div>
                    <div class="pipeline-group-content">
                        <div class="latency-item">
                            <span style="width: 140px; font-size: 0.85em;">‚Üì <span id="pairingExtension">----</span> (latency correction)</span>
                            <div class="sync-bar-container">
                                <div class="sync-bar-track">
                                    <div class="sync-bar-negative-zone"></div>
                                    <div class="sync-bar-positive-zone"></div>
                                </div>
                                <div class="sync-bar-center-line"></div>
                                <div class="sync-bar-center-label">0</div>
                                <div class="sync-bar-fill zero" id="syncCorrectionBar" style="width: 40px;">0 ms</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="chart-container large-chart">
                <canvas id="e2eChart"></canvas>
            </div>
        </div>

        <div class="grid">
            <!-- Audio Pipeline -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <span>üéµ Audio Processing Pipeline</span>
                    </div>
                </div>
                <div class="pipeline-viz">
                    <div class="pipeline-step active">
                        <div class="pipeline-icon">üì•</div>
                        <div class="pipeline-info">
                            <div class="pipeline-name">Frame Collector</div>
                            <div class="pipeline-latency">< 1ms ¬∑ 640 bytes @ 20ms</div>
                        </div>
                    </div>
                    <div class="pipeline-step">
                        <div class="pipeline-icon">üéØ</div>
                        <div class="pipeline-info">
                            <div class="pipeline-name">Prosodic Segmenter</div>
                            <div class="pipeline-latency">~3ms ¬∑ VAD + Boundaries</div>
                        </div>
                    </div>
                    <div class="pipeline-step">
                        <div class="pipeline-icon">üìä</div>
                        <div class="pipeline-info">
                            <div class="pipeline-name">Pacing Governor</div>
                            <div class="pipeline-latency">< 1ms ¬∑ Strict 20ms cadence</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Active Participants -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <span>üë• Active Participants</span>
                    </div>
                    <span class="metric-value" id="participantCount">0</span>
                </div>
                <div class="participants-list" id="participantsList">
                    <div class="loading">
                        <div class="loading-spinner"></div>
                        <div>Waiting for participants...</div>
                    </div>
                </div>
            </div>

            <!-- Emotion Analysis -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <span>üòä Real-Time Emotion Detection</span>
                    </div>
                </div>
                <div class="emotion-viz">
                    <div class="emotion-bar">
                        <div class="emotion-label">
                            <span>Arousal</span>
                            <span id="emotionArousal">0.50</span>
                        </div>
                        <div class="emotion-progress">
                            <div class="emotion-fill" id="emotionArousalBar" style="width: 50%;"></div>
                        </div>
                    </div>
                    <div class="emotion-bar">
                        <div class="emotion-label">
                            <span>Valence</span>
                            <span id="emotionValence">0.00</span>
                        </div>
                        <div class="emotion-progress">
                            <div class="emotion-fill" id="emotionValenceBar" style="width: 50%;"></div>
                        </div>
                    </div>
                    <div class="emotion-bar">
                        <div class="emotion-label">
                            <span>Energy</span>
                            <span id="emotionEnergy">0.50</span>
                        </div>
                        <div class="emotion-progress">
                            <div class="emotion-fill" id="emotionEnergyBar" style="width: 50%;"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- API Quota Usage -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <span>üìä API Quota Usage (Monthly)</span>
                    </div>
                </div>
                <div class="quota-card">
                    <div class="quota-header">
                        <span class="quota-service">Deepgram</span>
                        <span class="quota-percent" id="quotaDeepgram">10.4%</span>
                    </div>
                    <div class="quota-bar">
                        <div class="quota-fill low" style="width: 10.4%;"></div>
                    </div>
                </div>
                <div class="quota-card">
                    <div class="quota-header">
                        <span class="quota-service">DeepL</span>
                        <span class="quota-percent" id="quotaDeepl">25.0%</span>
                    </div>
                    <div class="quota-bar">
                        <div class="quota-fill medium" style="width: 25%;"></div>
                    </div>
                </div>
                <div class="quota-card">
                    <div class="quota-header">
                        <span class="quota-service">ElevenLabs</span>
                        <span class="quota-percent" id="quotaElevenlabs">32.0%</span>
                    </div>
                    <div class="quota-bar">
                        <div class="quota-fill medium" style="width: 32%;"></div>
                    </div>
                </div>
                <div class="quota-card">
                    <div class="quota-header">
                        <span class="quota-service">Hume AI</span>
                        <span class="quota-percent" id="quotaHume">45.0%</span>
                    </div>
                    <div class="quota-bar">
                        <div class="quota-fill medium" style="width: 45%;"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="timestamp" id="lastUpdate">Last updated: Never</div>
    </div>

    <script>
        // Socket.IO connection
        const socket = io();

        // Get extension from URL parameter (e.g., ?ext=7777)
        const urlParams = new URLSearchParams(window.location.search);
        const filterExtension = urlParams.get('ext'); // '7777' or '7888' or null

        console.log('[Dashboard] Filtering for extension:', filterExtension || 'ALL');

        // Update page title to show extension
        if (filterExtension) {
            document.title = `Extension ${filterExtension} - Real-Time Translation Dashboard`;

            // Add visual indicator at top
            const header = document.querySelector('.header h1');
            if (header) {
                const badge = filterExtension === '7777' ? 'üìû Caller' : 'üì± Answerer';
                header.textContent = `Extension ${filterExtension} (${badge})`;
            }
        }

        console.log("[CLIENT DEBUG] Socket.IO initialized:", socket);
        socket.on("connect", () => console.log("[CLIENT DEBUG] Socket connected! ID:", socket.id));
        socket.on("disconnect", () => console.log("[CLIENT DEBUG] Socket disconnected!"));
        socket.on("error", (err) => console.error("[CLIENT DEBUG] Socket error:", err));

        // Auto-refresh state
        let autoRefresh = true;
        let autoRefreshInterval;

        // Charts
        let charts = {};

        // Initialize dashboard
        function initDashboard() {
            createCharts();
            startAutoRefresh();
            subscribeToEvents();
            refreshDashboard();
        }

        // Create all charts
        function createCharts() {
            const chartConfig = (label, color) => ({
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: label,
                        data: [],
                        borderColor: color,
                        backgroundColor: color + '20',
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: { display: false },
                        y: {
                            beginAtZero: true,
                            ticks: { color: '#aaa' },
                            grid: { color: '#2a3f5f' }
                        }
                    }
                }
            });

            charts.deepgram = new Chart(
                document.getElementById('deepgramChart'),
                chartConfig('Latency (ms)', '#ff6b6b')
            );

            charts.deepl = new Chart(
                document.getElementById('deeplChart'),
                chartConfig('Latency (ms)', '#4dabf7')
            );

            charts.elevenlabs = new Chart(
                document.getElementById('elevenlabsChart'),
                chartConfig('Latency (ms)', '#a78bfa')
            );

            charts.hume = new Chart(
                document.getElementById('humeChart'),
                chartConfig('Latency (ms)', '#51cf66')
            );

            // E2E Chart
            charts.e2e = new Chart(
                document.getElementById('e2eChart'),
                {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Total Latency',
                                data: [],
                                borderColor: '#667eea',
                                backgroundColor: '#667eea20',
                                fill: true,
                                tension: 0.4
                            },
                            {
                                label: 'Target (900ms)',
                                data: [],
                                borderColor: '#ff6b6b',
                                borderDash: [5, 5],
                                fill: false
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                labels: { color: '#eee' }
                            }
                        },
                        scales: {
                            x: {
                                ticks: { color: '#aaa' },
                                grid: { color: '#2a3f5f' }
                            },
                            y: {
                                beginAtZero: true,
                                max: 1200,
                                ticks: { color: '#aaa' },
                                grid: { color: '#2a3f5f' }
                            }
                        }
                    }
                }
            );
        }

        // Subscribe to Socket.IO events
        function subscribeToEvents() {
            console.log("[CLIENT DEBUG] subscribeToEvents() called - registering listeners");
            // Join monitoring room to receive audio streams and transcriptions
            socket.emit('subscribe', { room: 'monitoring' });
            console.log('[Dashboard] Subscribed to monitoring room');

            socket.on('metrics_update', (data) => {
                if (filterExtension && data.extension !== filterExtension) return;
                updateMetrics(data);
            });

            socket.on('participant_joined', (data) => {
                if (filterExtension && data.extension !== filterExtension) return;
                addParticipant(data);
            });

            socket.on('participant_left', (data) => {
                if (filterExtension && data.extension !== filterExtension) return;
                removeParticipant(data);
            });

            socket.on('emotionData', (data) => {
                console.log('[Filter] emotionData - filterExtension:', filterExtension, 'data.extensionId:', data.extensionId);
                // Filter by extension if URL param is set
                if (filterExtension && data.extensionId !== filterExtension) {
                    return; // Skip events from other extensions
                }
                console.log("[CLIENT DEBUG] emotionData event received!", data);
                updateHumeEmotions(data);
            });

            socket.on('latency_measurement', (data) => {
                if (filterExtension && data.extension !== filterExtension) return;
                updateLatencyCharts(data);
            });

            socket.on('service_status', (data) => {
                if (filterExtension && data.extension !== filterExtension) return;
                updateServiceStatus(data);
            });

            // Live transcription events
            socket.on('transcriptionPartial', (data) => {
                console.log('[Filter] transcriptionPartial - filterExtension:', filterExtension, 'data.extension:', data.extension);
                // Filter by extension if URL param is set
                if (filterExtension && data.extension !== filterExtension) {
                    return; // Skip events from other extensions
                }
                // Update Extension Monitor
                if (!window.extensionMonitorData) window.extensionMonitorData = { packetCount: 0 };
                window.extensionMonitorData.packetCount++;
                if (document.getElementById('extensionNumber') && data.extension) {
                    document.getElementById('extensionNumber').textContent = data.extension;
                    document.getElementById('extensionNumber').style.color = data.extension === '7777' ? '#667eea' : '#51cf66';
                }
                if (document.getElementById('callUuid') && data.uuid) {
                    document.getElementById('callUuid').textContent = data.uuid;
                }
                if (document.getElementById('packetCount')) {
                    document.getElementById('packetCount').textContent = window.extensionMonitorData.packetCount.toLocaleString();
                }
                if (document.getElementById('lastPacketTime')) {
                    document.getElementById('lastPacketTime').textContent = new Date().toLocaleTimeString();
                }
                if (document.getElementById('extensionBadge') && data.extension) {
                    const badge = data.extension === '7777' ? 'üìû CALLER' : 'üì± ANSWERER';
                    document.getElementById('extensionBadge').textContent = 'EXT ' + data.extension + ' - ' + badge;
                    document.getElementById('extensionBadge').style.color = data.extension === '7777' ? '#667eea' : '#51cf66';
                }
                console.log('[Dashboard] Received transcriptionPartial:', data);
                addTranscript(data, 'partial');
            });

            // Outbound audio - tracks TTS audio from bridge being sent back to Asterisk
            socket.on('translatedAudio', (data) => {
                // Filter by extension if URL param is set
                if (filterExtension && data.extension !== filterExtension) {
                    return; // Skip events from other extensions
                }

                console.log('[Card #6] translatedAudio event received:', data.extension, data.uuid);

                // Initialize outbound monitor data
                if (!window.outboundMonitorData) window.outboundMonitorData = { packetCount: 0 };
                window.outboundMonitorData.packetCount++;

                // Update outbound stream card
                if (document.getElementById('outboundExtensionNumber') && data.extension) {
                    document.getElementById('outboundExtensionNumber').textContent = data.extension;
                    document.getElementById('outboundExtensionNumber').style.color = data.extension === '7777' ? '#5b6fd8' : '#764ba2';
                }
                if (document.getElementById('outboundBridgeId') && data.uuid) {
                    document.getElementById('outboundBridgeId').textContent = String(data.uuid).substring(0, 30) + '...';
                }
                if (document.getElementById('outboundCallUuid') && data.uuid) {
                    document.getElementById('outboundCallUuid').textContent = data.uuid;
                }
                if (document.getElementById('outboundPacketCount')) {
                    document.getElementById('outboundPacketCount').textContent = window.outboundMonitorData.packetCount.toLocaleString();
                }
                if (document.getElementById('outboundLastPacketTime')) {
                    document.getElementById('outboundLastPacketTime').textContent = new Date().toLocaleTimeString();
                }

                // Update status badge
                if (document.getElementById('asteriskOutboundStreamStatus')) {
                    document.getElementById('asteriskOutboundStreamStatus').textContent = '‚ñ∂ Active';
                    document.getElementById('asteriskOutboundStreamStatus').className = 'status-badge status-active';
                }

                // Handle audio playback using Web Audio API (like Card #4)
                if (data.audio) {
                    const audioIndicator = document.getElementById('asteriskOutboundIndicator');
                    const audioStatus = document.getElementById('asteriskOutboundStatus');

                    // Update status
                    if (audioStatus) {
                        audioStatus.textContent = 'Playing translated audio...';
                    }
                    if (audioIndicator) {
                        audioIndicator.classList.add('active');
                    }

                    // Initialize Web Audio API context if not already created
                    if (!window.asteriskOutboundAudioContext) {
                        window.asteriskOutboundAudioContext = new (window.AudioContext || window.webkitAudioContext)({
                            sampleRate: data.sampleRate || 16000
                        });
                        window.asteriskOutboundNextPlayTime = window.asteriskOutboundAudioContext.currentTime;

                        // Create global gain node for volume control
                        window.asteriskOutboundGainNode = window.asteriskOutboundAudioContext.createGain();
                        window.asteriskOutboundGainNode.gain.value = 0.0;  // Start at 0% (matches slider default)
                        window.asteriskOutboundGainNode.connect(window.asteriskOutboundAudioContext.destination);
                        console.log('[Card #6] Web Audio Context initialized at', data.sampleRate, 'Hz');
                    }

                    // Resume AudioContext if suspended (browser autoplay policy)
                    if (window.asteriskOutboundAudioContext.state === 'suspended') {
                        window.asteriskOutboundAudioContext.resume().then(() => {
                            console.log('[Card #6] AudioContext resumed - audio should now play');
                        }).catch(err => {
                            console.error('[Card #6] Failed to resume AudioContext:', err);
                        });
                    }

                    // Decode base64 PCM audio and play
                    try {
                        const pcmBase64 = data.audio;
                        const pcmBinary = atob(pcmBase64);
                        const pcmData = new Int16Array(pcmBinary.length / 2);

                        // Convert binary string to Int16Array
                        for (let i = 0; i < pcmData.length; i++) {
                            const byte1 = pcmBinary.charCodeAt(i * 2);
                            const byte2 = pcmBinary.charCodeAt(i * 2 + 1);
                            pcmData[i] = (byte2 << 8) | byte1; // Little-endian
                        }

                        // Convert Int16 PCM to Float32 for Web Audio API
                        const float32Data = new Float32Array(pcmData.length);
                        for (let i = 0; i < pcmData.length; i++) {
                            float32Data[i] = pcmData[i] / 32768.0;
                        }

                        // Create audio buffer
                        const sampleRate = data.sampleRate || 16000;
                        const audioBuffer = window.asteriskOutboundAudioContext.createBuffer(1, float32Data.length, sampleRate);
                        audioBuffer.getChannelData(0).set(float32Data);

                        // Create buffer source and connect to gain node
                        const source = window.asteriskOutboundAudioContext.createBufferSource();
                        source.buffer = audioBuffer;
                        source.connect(window.asteriskOutboundGainNode);

                        // Schedule playback
                        if (window.asteriskOutboundNextPlayTime < window.asteriskOutboundAudioContext.currentTime) {
                            window.asteriskOutboundNextPlayTime = window.asteriskOutboundAudioContext.currentTime;
                        }
                        source.start(window.asteriskOutboundNextPlayTime);
                        window.asteriskOutboundNextPlayTime += audioBuffer.duration;

                        console.log('[Card #6] Playing audio chunk:', float32Data.length, 'samples,', audioBuffer.duration.toFixed(2), 's');

                        // Start visualization animation if not already running
                        if (!window.asteriskOutboundAnimating) {
                            window.asteriskOutboundAnimating = true;
                            drawAsteriskOutboundVisualizer();
                        }
                    } catch (err) {
                        console.error('[Card #6] Audio processing error:', err);
                    }
                }
            });

            socket.on('transcriptionFinal', (data) => {
                console.log('[Filter] transcriptionFinal - filterExtension:', filterExtension, 'data.extension:', data.extension);
                // Filter by extension if URL param is set
                if (filterExtension && data.extension !== filterExtension) {
                    return; // Skip events from other extensions
                }
                // [PHASE 1] Store ASR latency from Deepgram
                if (data.latency) {
                    latestASRLatency = data.latency;
                    console.log('[Dashboard] ASR latency:', latestASRLatency, 'ms');
                }

                console.log('[Dashboard] Received transcriptionFinal:', data);
                addTranscript(data, 'final');

                // Update Deepgram status badge
                const deepgramStatus = document.getElementById("deepgramStatus");
                const deepgramIndicator = document.getElementById("deepgramActivityIndicator");
                const deepgramText = document.getElementById("deepgramActivityText");
                if (deepgramStatus) {
                    deepgramStatus.className = "status-badge status-operational";
                    deepgramStatus.textContent = "üéôÔ∏è TRANSCRIBING";
                }
                if (deepgramIndicator) deepgramIndicator.style.background = "#10b981";
                if (deepgramText) deepgramText.textContent = "Transcription active...";
            });


            // DeepL Translation Complete event
            socket.on("translationComplete", (data) => {
                console.log("[Dashboard] Translation complete:", data);
                // Filter by extension
                if (filterExtension && data.extension !== filterExtension) {
                    return; // Skip events from other extensions
                }
                
                // Update DeepL status
                document.getElementById("deeplStatus").textContent = "‚úÖ Active";
                document.getElementById("deeplStatus").style.background = "#10b981";
                
                // Use new addTranslation function for scrolling display
                addTranslation(data);

                // Update language pair (if element exists)
                const langPairElement = document.getElementById("deeplLanguagePair");
                if (langPairElement) {
                    langPairElement.textContent = data.sourceLang + " ‚Üí " + data.targetLang;
                }

                // Update translation time (if element exists)
                const timeElement = document.getElementById("deeplTranslationTime");
                if (timeElement) {
                    timeElement.textContent = data.time + " ms";
                }
            });

            // AUDIO STREAM FORK - Receive same audio as Deepgram
            socket.on('audioStream', handleAudioStreamFromFork);

            // ========================================================================
            // PHASE 1: REAL LATENCY DATA from pipelineComplete
            // ========================================================================

            // Store latest latencies for aggregation
            let latestASRLatency = 0;
            let latestMTLatency = 0;
            let latestTTSLatency = 0;
            let latencyDataCount = 0;

            // Listen for pipeline complete with REAL latency data
            socket.on('pipelineComplete', (data) => {
                console.log('[Filter] pipelineComplete - filterExtension:', filterExtension, 'data.extension:', data.extension);
                // Filter by extension if URL param is set
                if (filterExtension && data.extension !== filterExtension) {
                    return; // Skip events from other extensions
                }
                console.log('[Dashboard] üìä REAL Latency Data:', data);

                const {
                    totalTime,          // End-to-end pipeline time
                    translationTime,    // DeepL MT time
                    ttsTime,            // ElevenLabs TTS time
                    convertTime,        // Downsampling time
                    sendTime,           // Asterisk send time
                    humeTime,           // Hume parallel processing time
                    asrToMtNetwork,
                    mtToTtsNetwork,
                    ttsToDownsampleNetwork,
                    downsampleToSendNetwork
                } = data;

                // Store latest latencies
                latestMTLatency = translationTime || 0;
                latestTTSLatency = ttsTime || 0;
                latencyDataCount++;

                // Calculate total display latency
                const totalDisplayLatency = totalTime + (convertTime || 0) + (sendTime || 0);

                // Update E2E Latency Card
                const e2eElement = document.getElementById('e2eLatency');
                if (e2eElement) {
                    e2eElement.textContent = Math.round(totalDisplayLatency) + 'ms';
                    updateLatencyClass(e2eElement, totalDisplayLatency, 900);
                }

                // Update provider latency cards
                if (latestASRLatency > 0) {
                    const deepgramElement = document.getElementById('deepgramLatency');
                    if (deepgramElement) {
                        deepgramElement.textContent = Math.round(latestASRLatency) + 'ms';
                        updateLatencyClass(deepgramElement, latestASRLatency, 250);
                    }
                }

                const deeplElement = document.getElementById('deeplLatency');
                if (deeplElement) {
                    deeplElement.textContent = Math.round(translationTime) + 'ms';
                    updateLatencyClass(deeplElement, translationTime, 200);
                }

                const elevenlabsElement = document.getElementById('elevenlabsLatency');
                if (elevenlabsElement) {
                    elevenlabsElement.textContent = Math.round(ttsTime) + 'ms';
                    updateLatencyClass(elevenlabsElement, ttsTime, 250);
                }

                // Update breakdown bars
                updateLatencyBars(
                    latestASRLatency,
                    translationTime,
                    ttsTime,
                    humeTime || 0,  // Hume latency from server
                    totalDisplayLatency
                );


                // UPDATE NETWORK LATENCY BARS
                if (typeof asrToMtNetwork !== "undefined" && asrToMtNetwork !== null) {
                    const bar = document.getElementById("latencyBarAsrMt");
                    if (bar) {
                        bar.style.width = Math.min((asrToMtNetwork / 900) * 100, 100) + "%";
                        bar.textContent = asrToMtNetwork.toFixed(1) + "ms";
                    }
                }
                if (typeof mtToTtsNetwork !== "undefined" && mtToTtsNetwork !== null) {
                    const bar = document.getElementById("latencyBarMtTts");
                    if (bar) {
                        bar.style.width = Math.min((mtToTtsNetwork / 900) * 100, 100) + "%";
                        bar.textContent = mtToTtsNetwork.toFixed(1) + "ms";
                    }
                }
                if (typeof ttsToDownsampleNetwork !== "undefined" && ttsToDownsampleNetwork !== null) {
                    const bar = document.getElementById("latencyBarTtsDs");
                    if (bar) {
                        bar.style.width = Math.min((ttsToDownsampleNetwork / 900) * 100, 100) + "%";
                        bar.textContent = ttsToDownsampleNetwork.toFixed(1) + "ms";
                    }
                }
                if (typeof downsampleToSendNetwork !== "undefined" && downsampleToSendNetwork !== null) {
                    const bar = document.getElementById("latencyBarDsSend");
                    if (bar) {
                        bar.style.width = Math.min((downsampleToSendNetwork / 900) * 100, 100) + "%";
                        bar.textContent = downsampleToSendNetwork.toFixed(1) + "ms";
                    }
                }

                // Update charts with REAL data
                const now = new Date().toLocaleTimeString();

                if (latestASRLatency > 0) {
                    updateChart(charts.deepgram, now, latestASRLatency);
                }
                updateChart(charts.deepl, now, translationTime);
                updateChart(charts.elevenlabs, now, ttsTime);
                updateE2EChart(now, totalDisplayLatency);

                console.log('[Dashboard] ‚úÖ Updated with real latency:', {
                    asr: latestASRLatency,
                    mt: translationTime,
                    tts: ttsTime,
                    total: totalDisplayLatency,
                    count: latencyDataCount
                });
            });

            // ElevenLabs Metrics Update
            socket.on('elevenlabsMetrics', (data) => {
                console.log("[ElevenLabs] Metrics update:", JSON.stringify(data));
                
                // Update latency (p95)
                
                const latencyEl = document.getElementById('elevenlabsLatency');
                if (latencyEl && data.latency !== undefined) {
                    latencyEl.textContent = data.latency + ' ms';
                    
                    // Color coding for latency
                    latencyEl.classList.remove('good', 'warning', 'critical');
                    if (data.latency < 1000) {
                        latencyEl.classList.add('good');
                    } else if (data.latency < 2000) {
                        latencyEl.classList.add('warning');
                    } else {
                        latencyEl.classList.add('critical');
                    }
                }
                
                // Update requests per minute
                const requestsEl = document.getElementById('elevenlabsRequests');
                if (requestsEl && data.requestsPerMinute !== undefined) {
                    requestsEl.textContent = data.requestsPerMinute;
                }
                
                // Update error rate
                const errorsEl = document.getElementById('elevenlabsErrors');
                if (errorsEl && data.errorRate !== undefined) {
                    errorsEl.textContent = data.errorRate + '%';
                    
                    // Color coding for error rate
                    errorsEl.classList.remove('good', 'warning', 'critical');
                    if (data.errorRate < 2) {
                        errorsEl.classList.add('good');
                    } else if (data.errorRate < 5) {
                        errorsEl.classList.add('warning');
                    } else {
                        errorsEl.classList.add('critical');
                    }
                }
                
                // Update status badge
                const statusEl = document.getElementById('elevenlabsStatus');
                if (statusEl) {
                    statusEl.classList.remove('status-operational', 'status-warning', 'status-error');
                    if (data.status === 'ok') {
                        statusEl.classList.add('status-operational');
                        statusEl.textContent = '‚úì OK';
                    } else if (data.status === 'warning') {
                        statusEl.classList.add('status-warning');
                        statusEl.textContent = '‚ö† WARNING';
                    } else {
                        statusEl.classList.add('status-error');
                        statusEl.textContent = '‚úó ERROR';
                    }
                }
            });

            // Also capture ASR latency from transcriptionFinal
            const originalTranscriptionFinalHandler = socket._callbacks['$transcriptionFinal'];


            // TRANSLATED AUDIO - Receive translated audio from ElevenLabs
            socket.on('translatedAudio', handleTranslatedAudio);

            // Listen for Hume‚ÜíElevenLabs status updates
            socket.on('hume_to_elevenlabs', (data) => {
                if (filterExtension && data.extension !== filterExtension) return;
                updateHumeToElevenLabsStatus(data);
            });
        }

        // Refresh dashboard data

        // Helper function to create WAV header for PCM audio
        function createWavHeader(pcmLength, sampleRate, numChannels, bitsPerSample) {
            const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
            const blockAlign = numChannels * (bitsPerSample / 8);
            const dataSize = pcmLength;
            const fileSize = 36 + dataSize;

            const header = new ArrayBuffer(44);
            const view = new DataView(header);

            // RIFF chunk descriptor
            view.setUint32(0, 0x52494646, false); // "RIFF"
            view.setUint32(4, fileSize, true);    // File size - 8
            view.setUint32(8, 0x57415645, false); // "WAVE"

            // fmt sub-chunk
            view.setUint32(12, 0x666d7420, false); // "fmt "
            view.setUint32(16, 16, true);          // Subchunk1Size (16 for PCM)
            view.setUint16(20, 1, true);           // AudioFormat (1 for PCM)
            view.setUint16(22, numChannels, true); // NumChannels
            view.setUint32(24, sampleRate, true);  // SampleRate
            view.setUint32(28, byteRate, true);    // ByteRate
            view.setUint16(32, blockAlign, true);  // BlockAlign
            view.setUint16(34, bitsPerSample, true); // BitsPerSample

            // data sub-chunk
            view.setUint32(36, 0x64617461, false); // "data"
            view.setUint32(40, dataSize, true);    // Subchunk2Size

            return new Uint8Array(header);
        }

        // QA Settings: Update language configuration
        function updateQASettings() {
            const sourceLang = document.getElementById('qaSourceLang').value;
            const targetLang = document.getElementById('qaTargetLang').value;
            const modeElement = document.getElementById('qaTranslationMode');

            // Update UI to show current mode
            if (sourceLang === targetLang) {
                modeElement.innerHTML = '‚ö†Ô∏è QA Mode (No Translation)';
                modeElement.style.color = '#fcc419';
            } else {
                modeElement.innerHTML = '‚úì Translation Enabled';
                modeElement.style.color = '#51cf66';
            }

            // Emit configuration to server (with safety check)
            if (socket && socket.connected) {
                // If no extension filter, update BOTH 3333 and 4444
                const extensionsToUpdate = filterExtension ? [filterExtension] : ['3333', '4444'];
                
                extensionsToUpdate.forEach(ext => {
                    socket.emit('qa-language-config', {
                        extension: ext,
                        sourceLang: sourceLang,
                        targetLang: targetLang,
                        qaMode: sourceLang === targetLang
                    });
                    console.log(`[QA Settings] ‚úì Extension ${ext} updated: ${sourceLang} ‚Üí ${targetLang}`);
                });
            } else {
                console.warn('[QA Settings] Socket not connected, will retry on connect');
            }
        }

        // Initialize QA settings on page load
        // Enhanced latency update handler for Sync Manager
        socket.on('latencyUpdate', (data) => {
            console.log('[Dashboard] Sync Manager latency update:', data);

            // Filter by extension
            if (filterExtension && data.extension !== filterExtension) return;

            // Update individual service latencies from Sync Manager
            if (data.latencies) {
                // Deepgram (ASR) latency
                if (data.latencies.asr && data.latencies.asr.current > 0) {
                    const deepgramElement = document.getElementById('deepgramLatency');
                    if (deepgramElement) {
                        deepgramElement.textContent = Math.round(data.latencies.asr.current) + 'ms';
                        updateLatencyClass(deepgramElement, data.latencies.asr.current, 250);
                    }
                }

                // DeepL (MT) latency
                if (data.latencies.mt && data.latencies.mt.current > 0) {
                    const deeplElement = document.getElementById('deeplLatency');
                    if (deeplElement) {
                        deeplElement.textContent = Math.round(data.latencies.mt.current) + 'ms';
                        updateLatencyClass(deeplElement, data.latencies.mt.current, 200);
                    }
                }

                // ElevenLabs (TTS) latency
                if (data.latencies.tts && data.latencies.tts.current > 0) {
                    const elevenlabsElement = document.getElementById('elevenlabsLatency');
                    if (elevenlabsElement) {
                        elevenlabsElement.textContent = Math.round(data.latencies.tts.current) + 'ms';
                        updateLatencyClass(elevenlabsElement, data.latencies.tts.current, 250);
                    }
                }

                // End-to-End latency
                if (data.latencies.e2e && data.latencies.e2e.current > 0) {
                    const e2eElement = document.getElementById('e2eLatency');
                    if (e2eElement) {
                        e2eElement.textContent = Math.round(data.latencies.e2e.current) + 'ms';
                        updateLatencyClass(e2eElement, data.latencies.e2e.current, 900);
                    }
                }

                // Update latency breakdown bars
                // Serial pipeline stages
                const audiosocketToAsr = (data.latencies.audiosocket_to_asr && data.latencies.audiosocket_to_asr.current) || 0;
                const asr = (data.latencies.asr && data.latencies.asr.current) || 0;
                const asrToMt = (data.latencies.asr_to_mt && data.latencies.asr_to_mt.current) || 0;
                const mt = (data.latencies.mt && data.latencies.mt.current) || 0;
                const mtToTts = (data.latencies.mt_to_tts && data.latencies.mt_to_tts.current) || 0;
                const tts = (data.latencies.tts && data.latencies.tts.current) || 0;
                const ttsToLs = (data.latencies.tts_to_ls && data.latencies.tts_to_ls.current) || 0;
                const ls = (data.latencies.ls && data.latencies.ls.current) || 0;
                const lsToBridge = (data.latencies.ls_to_bridge && data.latencies.ls_to_bridge.current) || 0;

                // Parallel pipeline stages
                const audiosocketToEv = (data.latencies.audiosocket_to_ev && data.latencies.audiosocket_to_ev.current) || 0;
                const hume = (data.latencies.hume && data.latencies.hume.current) || 0;
                const evToTts = (data.latencies.ev_to_tts && data.latencies.ev_to_tts.current) || 0;

                // Totals (use server-calculated value that includes positive sync adjustment)
                const serialTotal = data.displaySerialTotalWithSync || data.displaySerialTotal || (data.latencies.serial_total && data.latencies.serial_total.current) || 0;
                const parallelTotal = (data.latencies.parallel_total && data.latencies.parallel_total.current) || 0;
                const total = (data.latencies.e2e && data.latencies.e2e.current) || 0;

                updateLatencyBars(
                    audiosocketToAsr, asr, asrToMt, mt, mtToTts, tts, ttsToLs, ls, lsToBridge,
                    audiosocketToEv, hume, evToTts,
                    serialTotal, parallelTotal, total
                );

                // Update sync correction bar
                if (data.buffer) {
                    updateSyncCorrectionBar(data.buffer.adjustment || 0, data.buffer.reason || '');
                }
            }

            // Log buffer and sync info
            if (data.buffer) {
                console.log('[Dashboard] Buffer:', data.buffer.current + 'ms, Target:', data.buffer.target + 'ms');
            }
            if (data.stats) {
                console.log('[Dashboard] Stats - Utterances:', data.stats.utteranceCount,
                           'Avg Latency:', data.stats.avgUtteranceLatency + 'ms');
            }
        });

        socket.on('connect', () => {
            updateQASettings();
        });

        function refreshDashboard() {
            // Simulate data refresh (replace with actual API calls)
            // PHASE 1: DISABLED - updateSimulatedMetrics();
            updateTimestamp();
        }

        // Update simulated metrics (for demo)
        // PHASE 1: DISABLED SIMULATED DATA
        // function updateSimulatedMetrics() {
            // // Update latency values
            // const now = new Date().toLocaleTimeString();

            // // Deepgram
            // const dgLatency = 220 + Math.random() * 40;
            // updateChart(charts.deepgram, now, dgLatency);
            // document.getElementById('deepgramLatency').textContent = Math.round(dgLatency) + 'ms';
            // updateLatencyClass(document.getElementById('deepgramLatency'), dgLatency, 250);

            // // DeepL
            // const dlLatency = 170 + Math.random() * 40;
            // updateChart(charts.deepl, now, dlLatency);
            // document.getElementById('deeplLatency').textContent = Math.round(dlLatency) + 'ms';
            // updateLatencyClass(document.getElementById('deeplLatency'), dlLatency, 200);

            // // ElevenLabs
            // const elLatency = 230 + Math.random() * 40;
            // updateChart(charts.elevenlabs, now, elLatency);
            // document.getElementById('elevenlabsLatency').textContent = Math.round(elLatency) + 'ms';
            // updateLatencyClass(document.getElementById('elevenlabsLatency'), elLatency, 250);

            // // Hume
            // const hmLatency = 180 + Math.random() * 40;
            // updateChart(charts.hume, now, hmLatency);
            // document.getElementById('humeLatency').textContent = Math.round(hmLatency) + 'ms';
            // updateLatencyClass(document.getElementById('humeLatency'), hmLatency, 200);

            // // E2E
            // const e2eLatency = dgLatency + dlLatency + elLatency + 180;
            // updateE2EChart(now, e2eLatency);
            // document.getElementById('e2eLatency').textContent = Math.round(e2eLatency) + 'ms';
            // updateLatencyClass(document.getElementById('e2eLatency'), e2eLatency, 900);

            // // Update latency bars
            // // updateLatencyBars(dgLatency, dlLatency, elLatency, hmLatency, e2eLatency);
        // }

        // Update chart data
        function updateChart(chart, label, value) {
            chart.data.labels.push(label);
            chart.data.datasets[0].data.push(value);

            // Keep only last 20 data points
            if (chart.data.labels.length > 20) {
                chart.data.labels.shift();
                chart.data.datasets[0].data.shift();
            }

            chart.update('none');
        }

        // Update E2E chart
        function updateE2EChart(label, value) {
            charts.e2e.data.labels.push(label);
            charts.e2e.data.datasets[0].data.push(value);
            charts.e2e.data.datasets[1].data.push(900); // Target line

            // Keep only last 20 data points
            if (charts.e2e.data.labels.length > 20) {
                charts.e2e.data.labels.shift();
                charts.e2e.data.datasets[0].data.shift();
                charts.e2e.data.datasets[1].data.shift();
            }

            charts.e2e.update('none');
        }

        // Update latency class (good/warning/critical)
        function updateLatencyClass(element, value, target) {
            element.classList.remove('good', 'warning', 'critical');
            if (value <= target) {
                element.classList.add('good');
            } else if (value <= target * 1.2) {
                element.classList.add('warning');
            } else {
                element.classList.add('critical');
            }
        }

        // Helper function to format latency values
        function formatLatency(value) {
            if (value < 1) {
                return value.toFixed(2) + 'ms';
            } else {
                return Math.round(value) + 'ms';
            }
        }

        // Update latency breakdown bars
        function updateLatencyBars(
            audiosocketToAsr, asr, asrToMt, mt, mtToTts, tts, ttsToLs, ls, lsToBridge,
            audiosocketToEv, hume, evToTts,
            serialTotal, parallelTotal, total
        ) {
            const MAX_LATENCY = 900; // Reference max for bar width calculation

            // Serial Pipeline - Update bars
            updateBar('latencyBarAudioSocketAsr', audiosocketToAsr, MAX_LATENCY);
            updateBar('latencyBarAsr', asr, MAX_LATENCY);
            updateBar('latencyBarAsrMt', asrToMt, MAX_LATENCY);
            updateBar('latencyBarMt', mt, MAX_LATENCY);
            updateBar('latencyBarMtTts', mtToTts, MAX_LATENCY);
            updateBar('latencyBarTts', tts, MAX_LATENCY);
            updateBar('latencyBarTtsLs', ttsToLs, MAX_LATENCY);
            updateBar('latencyBarLs', ls, MAX_LATENCY);
            updateBar('latencyBarLsBridge', lsToBridge, MAX_LATENCY);

            // Parallel Pipeline - Update bars
            updateBar('latencyBarAudioSocketEv', audiosocketToEv, MAX_LATENCY);
            updateBar('latencyBarHume', hume, MAX_LATENCY);
            updateBar('latencyBarEvTts', evToTts, MAX_LATENCY);

            // Update group totals (serialTotal already includes positive sync adjustment from server)
            document.getElementById('serialTotal').textContent = formatLatency(serialTotal);
            document.getElementById('parallelTotal').textContent = formatLatency(parallelTotal);
        }

        // Helper function to update individual bar
        function updateBar(elementId, value, maxValue) {
            const element = document.getElementById(elementId);
            if (element) {
                const percentage = (value / maxValue) * 100;
                element.style.width = percentage + '%';
                element.textContent = formatLatency(value);
            }
        }

        // Update sync correction bar (bidirectional +/- bar)
        function updateSyncCorrectionBar(adjustment, reason) {
            const bar = document.getElementById('syncCorrectionBar');
            const pairingExt = document.getElementById('pairingExtension');

            if (!bar) return;

            const MAX_ADJUSTMENT = 300; // Max adjustment for visual scale (ms)
            const absAdjustment = Math.abs(adjustment);

            // Update pairing extension from reason (e.g., "sync_to_7888")
            if (reason && reason.startsWith('sync_to_')) {
                const targetExtension = reason.replace('sync_to_', '');
                if (pairingExt) {
                    pairingExt.textContent = targetExtension;
                }
            }

            // Remove all classes
            bar.classList.remove('positive', 'negative', 'zero');

            if (adjustment === 0) {
                // Zero state
                bar.classList.add('zero');
                bar.style.width = '40px';
                bar.textContent = '0 ms';
            } else if (adjustment > 0) {
                // Positive adjustment (adding delay)
                bar.classList.add('positive');
                const widthPercentage = Math.min((absAdjustment / MAX_ADJUSTMENT) * 50, 50);
                bar.style.width = widthPercentage + '%';
                bar.textContent = '+' + formatLatency(absAdjustment);
            } else {
                // Negative adjustment (removing delay / ahead)
                bar.classList.add('negative');
                const widthPercentage = Math.min((absAdjustment / MAX_ADJUSTMENT) * 50, 50);
                bar.style.width = widthPercentage + '%';
                bar.textContent = '-' + formatLatency(absAdjustment);
            }
        }

        // Update timestamp
        function updateTimestamp() {
            document.getElementById('lastUpdate').textContent =
                'Last updated: ' + new Date().toLocaleTimeString();
        }

        // Toggle auto-refresh
        function toggleAutoRefresh() {
            autoRefresh = !autoRefresh;
            const btn = document.getElementById('autoRefreshBtn');

            if (autoRefresh) {
                btn.textContent = '‚è∏Ô∏è Pause Auto-Refresh';
                startAutoRefresh();
            } else {
                btn.textContent = '‚ñ∂Ô∏è Resume Auto-Refresh';
                stopAutoRefresh();
            }
        }

        // Start auto-refresh
        function startAutoRefresh() {
            if (autoRefreshInterval) clearInterval(autoRefreshInterval);
            autoRefreshInterval = setInterval(refreshDashboard, 5000); // Every 5 seconds
        }

        // Stop auto-refresh
        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
        }

        // Export metrics to CSV
        function exportMetrics() {
            const csvContent = generateMetricsCSV();
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `metrics-${Date.now()}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Generate CSV from current metrics
        function generateMetricsCSV() {
            const timestamp = new Date().toISOString();
            return `Timestamp,Service,Latency_ms,Error_Rate,Requests_Per_Min
${timestamp},Deepgram,${document.getElementById('deepgramLatency').textContent},${document.getElementById('deepgramErrors').textContent},${document.getElementById('deepgramRequests').textContent}
${timestamp},DeepL,${document.getElementById('deeplLatency').textContent},${document.getElementById('deeplErrors').textContent},-
${timestamp},ElevenLabs,${document.getElementById('elevenlabsLatency').textContent},${document.getElementById('elevenlabsErrors').textContent},${document.getElementById('elevenlabsRequests').textContent}
${timestamp},Hume,${document.getElementById('humeLatency').textContent},${document.getElementById('humeErrors').textContent},${document.getElementById('humeRequests').textContent}
${timestamp},End-to-End,${document.getElementById('e2eLatency').textContent},-,-`;
        }

        // Transcription handling
        let autoScrollEnabled = true;
        let transcriptCount = 0;

        // Add transcript to the window
        function addTranscript(data, type) {
            const window = document.getElementById('transcriptionWindow');

            // Remove empty message if present
            const emptyMsg = window.querySelector('.transcript-empty');
            if (emptyMsg) {
                emptyMsg.remove();
            }

            // Create transcript element
            const transcriptLine = document.createElement('div');
            transcriptLine.className = `transcript-line ${type}`;
            transcriptLine.id = `transcript-${transcriptCount++}`;

            const timestamp = new Date().toLocaleTimeString();
            const typeLabel = type.toUpperCase();
            const text = data.text || '';
            const language = data.language || 'en';
            const confidence = data.confidence ? ` (${Math.round(data.confidence * 100)}%)` : '';

            transcriptLine.innerHTML = `
                <span class="transcript-timestamp">[${timestamp}]</span>
                <span class="transcript-type ${type}">${typeLabel}</span>
                <span class="transcript-text">${escapeHtml(text)}</span>
                <span style="color: #aaa; font-size: 0.85em;">${language}${confidence}</span>
            `;

            // For partial transcripts, replace the last partial if it exists
            if (type === 'partial') {
                const lastPartial = window.querySelector('.transcript-line.partial:last-child');
                if (lastPartial && window.children.length > 0) {
                    // Replace last partial with new one
                    lastPartial.replaceWith(transcriptLine);
                } else {
                    const emptyMsgCheck = window.querySelector(".transcript-empty"); if (emptyMsgCheck) window.removeChild(emptyMsgCheck); window.insertBefore(transcriptLine, window.firstChild);
                }
            } else {
                // For final transcripts, always append
                const emptyMsgCheck = window.querySelector(".transcript-empty"); if (emptyMsgCheck) window.removeChild(emptyMsgCheck); window.insertBefore(transcriptLine, window.firstChild);
            }

            // Keep ALL transcripts (no limit) - user requested to keep all lines with scroller

            // Auto-scroll to bottom if enabled
            if (autoScrollEnabled) {
                window.scrollTop = 0;
            }
        }

        // Add translation pair with scrolling (LIFO - newest at top)
        let translationCount = 0;
        function addTranslation(data) {
            const window = document.getElementById('deeplTranslationWindow');

            // Remove empty message if present
            const emptyMsg = window.querySelector('.translation-empty');
            if (emptyMsg) {
                emptyMsg.remove();
            }

            // Create translation element
            const translationLine = document.createElement('div');
            translationLine.className = 'translation-pair';
            translationLine.id = `translation-${translationCount++}`;
            translationLine.style.cssText = 'margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid #2a3f5f;';

            const timestamp = new Date().toLocaleTimeString();
            const original = escapeHtml(data.original || '');
            const translation = escapeHtml(data.translation || '');
            const sourceLang = data.sourceLang || 'en';
            const targetLang = data.targetLang || 'ja';
            const time = data.time ? ` (${data.time}ms)` : '';

            translationLine.innerHTML = `
                <div style="margin-bottom: 3px;">
                    <span style="color: #667eea; font-size: 0.85em; font-weight: bold;">[${timestamp}]</span>
                    <span style="color: #aaa; font-size: 0.75em;">${sourceLang} ‚Üí ${targetLang}${time}</span>
                </div>
                <div style="margin-bottom: 5px; padding-left: 10px; border-left: 2px solid #667eea;">
                    <div style="color: #999; font-size: 0.75em;">Original:</div>
                    <div style="color: #e0e0e0;">${original}</div>
                </div>
                <div style="padding-left: 10px; border-left: 2px solid #10b981;">
                    <div style="color: #999; font-size: 0.75em;">Translated:</div>
                    <div style="color: #10b981;">${translation}</div>
                </div>
            `;

            // Insert at top (LIFO - newest first)
            window.insertBefore(translationLine, window.firstChild);

            // Limit to 50 translations to prevent performance issues
            const translations = window.querySelectorAll('.translation-pair');
            if (translations.length > 50) {
                // Remove oldest translations (from the bottom)
                for (let i = 50; i < translations.length; i++) {
                    translations[i].remove();
                }
            }

            // Auto-scroll to top to show newest
            window.scrollTop = 0;
        }

        // Toggle auto-scroll
        function toggleAutoScroll() {
            autoScrollEnabled = !autoScrollEnabled;
            const btn = document.getElementById('toggleAutoScroll');

            if (autoScrollEnabled) {
                btn.textContent = 'üîÑ Auto-Scroll: ON';
                btn.classList.remove('disabled');
                // Scroll to bottom immediately
                const window = document.getElementById('transcriptionWindow');
                window.scrollTop = 0;
            } else {
                btn.textContent = '‚è∏Ô∏è Auto-Scroll: OFF';
                btn.classList.add('disabled');
            }
        }

        // Clear transcripts
        function clearTranscripts() {
            const window = document.getElementById('transcriptionWindow');
            window.innerHTML = '<div class="transcript-empty">üé§ Transcription cleared. Waiting for new transcriptions...</div>';
            transcriptCount = 0;
        }

        function clearTranslations() {
            const window = document.getElementById('translationWindow');
            const empty = document.getElementById('translationEmpty');
            window.innerHTML = '';
            if (empty) {
                empty.style.display = 'block';
                empty.textContent = 'üéôÔ∏è Translations cleared. Waiting for new translations...';
                window.appendChild(empty);
            }
            if (typeof translationCount !== 'undefined') {
                translationCount = 0;
            }
            const countEl = document.getElementById('elevenlabsTranslationCount');
            if (countEl) countEl.textContent = '0';
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============ AUDIO STREAMING & VISUALIZATION ============

        let incomingAudioContext, outgoingAudioContext;
        let incomingAnalyser, outgoingAnalyser;
        let incomingDataArray, outgoingDataArray;
        let incomingAnimationId, outgoingAnimationId;
        let currentCall = null;
        let callStartTime = null;
        let callDurationInterval = null;
        let audioStreamBuffer = []; // Buffer for incoming audio chunks
        let outgoingNextPlayTime = 0; // For Card 4 - ElevenLabs translated audio

        // Handle translated audio from ElevenLabs TTS - Card 4
        let incomingGainNode, outgoingGainNode;  // Global gain nodes for volume control
        function handleTranslatedAudio(data) {
            // Filter by extension
            if (filterExtension && data.extension !== filterExtension) {
                console.log('[Translated Audio] Skipping - wrong extension. Want:', filterExtension, 'Got:', data.extension);
                return;
            }
            console.log('[Translated Audio] Received:', {
                translation: data.translation,
                original: data.original,
                audioSize: data.audio ? data.audio.length : 0,
                sampleRate: data.sampleRate,
                duration: data.duration
            });

            // Initialize Web Audio API context if not already created
            if (!outgoingAudioContext) {
                outgoingAudioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: data.sampleRate || 8000
                });
                outgoingNextPlayTime = outgoingAudioContext.currentTime;
                
                // Create global gain node for volume control
                outgoingGainNode = outgoingAudioContext.createGain();
                outgoingGainNode.gain.value = 0.0;  // Start at 0% (matches slider default)
                outgoingGainNode.connect(outgoingAudioContext.destination);
                console.log('[Translated Audio] Web Audio Context initialized at', data.sampleRate, 'Hz');
                console.log('[Translated Audio] AudioContext state:', outgoingAudioContext.state);
            }

            // Resume AudioContext if suspended (browser autoplay policy)
            if (outgoingAudioContext.state === 'suspended') {
                outgoingAudioContext.resume().then(() => {
                    console.log('[Translated Audio] AudioContext resumed - audio should now play');
                }).catch(err => {
                    console.error('[Translated Audio] Failed to resume AudioContext:', err);
                });
            }

            // Update UI indicators
            const outgoingIndicator = document.getElementById('outgoingAudioIndicator');
            const outgoingStatus = document.getElementById('outgoingAudioStatus');
            
            if (outgoingIndicator) {
                outgoingIndicator.classList.add('active');
            }
            if (outgoingStatus) {
                outgoingStatus.textContent = 'Playing translated audio (' + data.translation.substring(0, 30) + '...)';
            }
            // Also update the status badge in card header
            const translatedStatusBadge = document.getElementById("translatedStreamStatus");
            if (translatedStatusBadge) {
                translatedStatusBadge.className = "status-badge status-operational";
                translatedStatusBadge.textContent = "üîä PLAYING";
            }

            // Add translated text to the translation window (LIFO)
            const translationWindow = document.getElementById('translationWindow');
            const translationEmpty = document.getElementById('translationEmpty');

            if (translationWindow) {
                // Hide empty state if visible
                if (translationEmpty) {
                    translationEmpty.style.display = 'none';
                }

                // Create translation entry
                const translationEntry = document.createElement('div');
                translationEntry.style.cssText = 'padding: 8px; margin-bottom: 8px; background: rgba(167, 139, 250, 0.1); border-left: 3px solid #a78bfa; border-radius: 4px;';

                // Original text
                const originalDiv = document.createElement('div');
                originalDiv.style.cssText = 'color: #888; font-size: 0.85em; margin-bottom: 4px;';
                originalDiv.textContent = '‚ñ∂ ' + data.original;
                translationEntry.appendChild(originalDiv);

                // Translated text
                const translatedDiv = document.createElement('div');
                translatedDiv.style.cssText = 'color: #a78bfa; font-weight: bold;';
                translatedDiv.textContent = 'üåê ' + data.translation;
                translationEntry.appendChild(translatedDiv);

                // Timestamp
                const timestampDiv = document.createElement('div');
                timestampDiv.style.cssText = 'color: #666; font-size: 0.75em; margin-top: 4px;';
                timestampDiv.textContent = new Date().toLocaleTimeString();
                translationEntry.appendChild(timestampDiv);

                // Insert at the top (LIFO)
                translationWindow.insertBefore(translationEntry, translationWindow.firstChild);

                // Keep only last 20 translations
                while (translationWindow.children.length > 20) {
                    translationWindow.removeChild(translationWindow.lastChild);
                }

                // Update translation count
                if (!window.translationCount) window.translationCount = 0;
                window.translationCount++;
                const countEl = document.getElementById('elevenlabsTranslationCount');
                if (countEl) countEl.textContent = window.translationCount;
            }

            // SIMPLE: Just play the MP3 directly
            try {
                const audio = document.getElementById('outgoingAudioPlayer');
                if (audio) {
                    audio.src = "data:audio/mpeg;base64," + data.audio;
                    
                    // Apply volume from slider
                    const volumeSlider = document.getElementById('outgoingVolume');
                    if (volumeSlider) {
                        audio.volume = volumeSlider.value / 100;
                    }
                    
                    audio.play().catch(err => console.error('[Audio] Play failed:', err));
                    console.log('[Translated Audio] Playing MP3 directly');
                }
                
                // Decode MP3 for visualization (parallel to playback)
                const binaryString = atob(data.audio);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                // Use Web Audio API to decode for visualization only
                if (!outgoingAudioContext) {
                    outgoingAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                outgoingAudioContext.decodeAudioData(bytes.buffer.slice(0)).then(audioBuffer => {
                    // Visualize waveform
                    const outgoingCanvas = document.getElementById('outgoingAudioViz');
                    if (outgoingCanvas) {
                        const ctx = outgoingCanvas.getContext('2d');
                        const width = outgoingCanvas.width;
                        const height = outgoingCanvas.height;
                        
                        ctx.fillStyle = '#0f1419';
                        ctx.fillRect(0, 0, width, height);
                        
                        const samples = audioBuffer.getChannelData(0);
                        ctx.strokeStyle = '#10b981';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        
                        const step = Math.max(1, Math.floor(samples.length / width));
                        for (let i = 0; i < width; i++) {
                            const sample = samples[i * step] || 0;
                            const y = height / 2 - (sample * height / 2);
                            if (i === 0) ctx.moveTo(i, y);
                            else ctx.lineTo(i, y);
                        }
                        ctx.stroke();
                        console.log('[Translated Audio] Waveform visualized');
                    }
                }).catch(err => {
                    console.error('[Translated Audio] Visualization failed:', err);
                });
                
            } catch (err) {
                console.error('[Translated Audio] Error:', err);
            }
        }

        // Handler for audioStream (incoming audio from Asterisk - fork from Deepgram)
        function handleAudioStreamFromFork(data) {
            // Filter by extension
            if (filterExtension && data.extension !== filterExtension) {
                return; // Skip audio from other extensions
            }

            // Update Extension Monitor Card
            if (!window.extensionMonitorData) {
                window.extensionMonitorData = { packetCount: 0 };
            }
            window.extensionMonitorData.packetCount++;
            
            const extensionNum = document.getElementById('extensionNumber');
            const callUuidElem = document.getElementById('callUuid');
            const packetCountElem = document.getElementById('packetCount');
            const lastPacketTimeElem = document.getElementById('lastPacketTime');
            const extensionBadge = document.getElementById('extensionBadge');
            const extensionStatus = document.getElementById('extensionStatus');
            
            if (extensionNum && data.extension) {
                extensionNum.textContent = data.extension;
                extensionNum.style.color = data.extension === '7777' ? '#667eea' : '#51cf66';
            }
            
            if (callUuidElem && data.uuid) {
                callUuidElem.textContent = data.uuid;
            }
            
            if (packetCountElem) {
                packetCountElem.textContent = window.extensionMonitorData.packetCount.toLocaleString();
            }
            
            if (lastPacketTimeElem) {
                const now = new Date();
                lastPacketTimeElem.textContent = now.toLocaleTimeString();
            }
            
            if (extensionBadge && data.extension) {
                const badge = data.extension === '7777' ? 'üìû CALLER' : 'üì± ANSWERER';
                extensionBadge.textContent = 'EXT ' + data.extension + ' - ' + badge;
                extensionBadge.style.color = data.extension === '7777' ? '#667eea' : '#51cf66';
            }
            
            if (extensionStatus) {
                extensionStatus.className = 'status-badge status-operational';
                extensionStatus.textContent = '‚óè LIVE';
            }
            // Initialize Web Audio API context if not already created
            if (!incomingAudioContext) {
                incomingAudioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: data.sampleRate || 8000
                });
                nextPlayTime = incomingAudioContext.currentTime;
                
                // Create global gain node for volume control
                incomingGainNode = incomingAudioContext.createGain();
                incomingGainNode.gain.value = 0.0;  // Start at 0% (matches slider default)
                incomingGainNode.connect(incomingAudioContext.destination);
                console.log('[Audio Fork] Web Audio Context initialized at', data.sampleRate, 'Hz');
                console.log('[Audio Fork] AudioContext state:', incomingAudioContext.state);
            }

            // Resume AudioContext if suspended (browser autoplay policy)
            if (incomingAudioContext.state === 'suspended') {
                incomingAudioContext.resume().then(() => {
                    console.log('[Audio Fork] AudioContext resumed - audio should now play');
                }).catch(err => {
                    console.error('[Audio Fork] Failed to resume AudioContext:', err);
                });
            }

            // Update UI indicators
            document.getElementById('incomingAudioIndicator').classList.add('active');
            
            // Also update the status badge in card header
            const statusBadge = document.getElementById('asteriskStreamStatus');
            if (statusBadge) {
                statusBadge.className = 'status-badge status-operational';
                statusBadge.textContent = 'üî¥ LIVE';
            }
            document.getElementById('incomingAudioStatus').textContent = 'Receiving audio stream (fork from Deepgram)';

            // Handle binary data (ArrayBuffer from Socket.IO)
            try {
                let samples;

                // Check if data.buffer is ArrayBuffer (binary from Socket.IO)
                if (data.buffer instanceof ArrayBuffer) {
                    samples = new Int16Array(data.buffer);
                    console.log('[Audio Fork] Received ArrayBuffer, decoded', samples.length, 'samples');
                } else if (typeof data.buffer === 'string') {
                    // Fallback: base64 string
                    const binaryString = atob(data.buffer);
                    const len = binaryString.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    samples = new Int16Array(bytes.buffer);
                    console.log('[Audio Fork] Decoded base64, got', samples.length, 'samples');
                } else {
                    console.error('[Audio Fork] Unknown buffer type:', typeof data.buffer);
                    return;
                }
                console.log('[Audio Fork] Decoded', samples.length, 'samples, range:',
                    Math.min(...samples), 'to', Math.max(...samples));

                // Convert Int16 PCM (-32768 to 32767) to Float32 (-1.0 to 1.0)
                const float32Samples = new Float32Array(samples.length);
                for (let i = 0; i < samples.length; i++) {
                    float32Samples[i] = samples[i] / 32768.0;
                }

                // Visualize waveform for Card 1 (Incoming Audio IN)
                const incomingCanvas = document.getElementById('incomingAudioViz');
                if (incomingCanvas) {
                    const ctx = incomingCanvas.getContext('2d');
                    const width = incomingCanvas.width;
                    const height = incomingCanvas.height;

                    // Clear canvas
                    ctx.fillStyle = '#0f1419';
                    ctx.fillRect(0, 0, width, height);

                    // Draw waveform
                    ctx.strokeStyle = '#3b82f6';  // Blue for incoming audio
                    ctx.lineWidth = 2;
                    ctx.beginPath();

                    const step = Math.max(1, Math.floor(samples.length / width));
                    for (let i = 0; i < width; i++) {
                        const sampleIndex = i * step;
                        const sample = samples[sampleIndex] || 0;
                        const amplitude = Math.abs(sample / 32768.0);
                        const y = height / 2 + (amplitude * height / 2) * (sample < 0 ? 1 : -1);

                        if (i === 0) {
                            ctx.moveTo(i, y);
                        } else {
                            ctx.lineTo(i, y);
                        }
                    }
                    ctx.stroke();

                    console.log('[Incoming Audio] Waveform visualized');
                }

                // Visualize waveform for Card 5 (Hume AI Emotion Detection)
                visualizeHumeAudio(samples);

                // Update Hume AI activity indicator
                const humeIndicator = document.getElementById('humeAudioIndicator');
                const humeStatus = document.getElementById('humeAudioStatus');
                const humeActivityIndicator = document.getElementById('humeActivityIndicator');
                const humeActivityText = document.getElementById('humeActivityText');

                if (humeIndicator) humeIndicator.classList.add('active');
                if (humeStatus) humeStatus.textContent = 'Receiving audio stream (same as Deepgram)';
                if (humeActivityIndicator) {
                    humeActivityIndicator.style.background = '#4dabf7';
                    humeActivityIndicator.style.boxShadow = '0 0 10px #4dabf7';
                }
                if (humeActivityText) {
                    humeActivityText.textContent = 'Audio stream active...';
                    humeActivityText.style.color = '#4dabf7';
                }

                // Only schedule audio playback if NOT muted (skip buffering when muted)
                if (!incomingMuted) {
                    // Create AudioBuffer
                    const audioBuffer = incomingAudioContext.createBuffer(
                        data.channels || 1,
                        float32Samples.length,
                        data.sampleRate || 8000
                    );

                    // Copy samples to buffer
                    audioBuffer.getChannelData(0).set(float32Samples);

                    // Schedule for playback
                    const source = incomingAudioContext.createBufferSource();
                    source.buffer = audioBuffer;

                    // Connect to global gain node (controlled by volume slider)
                    source.connect(incomingGainNode);

                    // Schedule playback with proper timing to avoid gaps
                    const playTime = Math.max(nextPlayTime, incomingAudioContext.currentTime);
                    source.start(playTime);

                    // Update next play time (duration = samples / sampleRate)
                    const duration = audioBuffer.length / audioBuffer.sampleRate;
                    nextPlayTime = playTime + duration;

                    console.log('[Audio Fork] Scheduled playback at', playTime.toFixed(3),
                        's, duration:', duration.toFixed(3), 's, next:', nextPlayTime.toFixed(3), 's');
                } else {
                    console.log('[Audio Fork] Muted - skipping audio scheduling');
                }

            } catch (err) {
                console.error('[Audio Fork] Error processing audio:', err);
            }
        }

        // Initialize audio visualizers
        function initAudioVisualizers() {

        // Handle translated audio from pipeline (ElevenLabs TTS output)
            // handleTranslatedAudio moved to global scope for Card 4

            // Incoming audio visualizer
            const incomingCanvas = document.getElementById('incomingAudioViz');
            const incomingCtx = incomingCanvas.getContext('2d');

            // Outgoing audio visualizer
            const outgoingCanvas = document.getElementById('outgoingAudioViz');
            const outgoingCtx = outgoingCanvas.getContext('2d');

            // Set up volume controls
            document.getElementById('incomingVolume').addEventListener('input', (e) => {
                const volume = e.target.value;
                document.getElementById('incomingVolumeLabel').textContent = volume + '%';
                
                // Control Web Audio API gain node instead of HTML5 audio element
                if (incomingGainNode) {
                    incomingGainNode.gain.value = volume / 100;
                    console.log('[Volume] Incoming volume set to', volume + '%');
                }
            });

            document.getElementById('outgoingVolume').addEventListener('input', (e) => {
                const volume = e.target.value;
                document.getElementById('outgoingVolumeLabel').textContent = volume + '%';

                // Control Web Audio API gain node instead of HTML5 audio element
                if (outgoingGainNode) {
                    outgoingGainNode.gain.value = volume / 100;
                    console.log('[Volume] Outgoing volume set to', volume + '%');
                }
            });

            // Asterisk Outbound volume control (Card #6)
            document.getElementById('asteriskOutboundVolume').addEventListener('input', (e) => {
                const volume = e.target.value;
                document.getElementById('asteriskOutboundVolumeLabel').textContent = volume + '%';

                // Control Web Audio API gain node (like Card #4)
                if (window.asteriskOutboundGainNode) {
                    window.asteriskOutboundGainNode.gain.value = volume / 100;
                    console.log('[Card #6] Volume set to', volume + '%');
                }
            });

            // Subscribe to audio stream events
            socket.on('audioStreamStart', handleAudioStreamStart);
            socket.on('audioStreamData', handleAudioStreamData);
            socket.on('audioStreamEnd', handleAudioStreamEnd);
            socket.on('callConnected', handleCallConnected);
            socket.on('callDisconnected', handleCallDisconnected);
            socket.on('recordingReady', handleRecordingReady);

            // Also listen for audiosocket events (different event names)
            socket.on('audiosocket-connected', (data) => {
                console.log('[Dashboard] audiosocket-connected event received:', data);
                if (filterExtension && data.extension !== filterExtension) return;
                handleCallConnected(data);
            });
            socket.on('audiosocket-disconnected', (data) => {
                console.log('[Dashboard] audiosocket-disconnected event received:', data);
                if (filterExtension && data.extension !== filterExtension) return;
                handleCallDisconnected(data);
            });
        }

        // Handle call connected
        function handleCallConnected(data) {
            if (filterExtension && data.extension !== filterExtension) return;
            console.log('[Dashboard] Call connected:', data);
            currentCall = data;
            callStartTime = Date.now();

            // Update UI with debug logging
            console.log('[Dashboard] Updating UI elements...');

            const callInfoEl = document.getElementById('callInfo');
            console.log('[Dashboard] callInfo element:', callInfoEl);
            if (callInfoEl) callInfoEl.style.display = 'block';

            const callUUIDEl = document.getElementById('callUUID');
            console.log('[Dashboard] callUUID element:', callUUIDEl);
            if (callUUIDEl) callUUIDEl.textContent = data.callUUID || data.uuid || 'Unknown';

            const statusEl = document.getElementById('asteriskStreamStatus');
            console.log('[Dashboard] asteriskStreamStatus element:', statusEl);
            if (statusEl) {
                statusEl.className = 'status-badge status-operational';
                statusEl.textContent = 'üî¥ LIVE';
                statusEl.style.backgroundColor = '#00ff00';  // Bright green - IMPOSSIBLE to miss!
                statusEl.style.color = '#000000';
                statusEl.style.fontWeight = 'bold';
                statusEl.style.fontSize = '16px';
                console.log('[Dashboard] Updated status to LIVE with green background');
                console.log('[Dashboard] Status text is now:', statusEl.textContent);
                console.log('[Dashboard] Status background is now:', statusEl.style.backgroundColor);
            }

            const audioStatusEl = document.getElementById('incomingAudioStatus');
            console.log('[Dashboard] incomingAudioStatus element:', audioStatusEl);
            if (audioStatusEl) audioStatusEl.textContent = 'Receiving audio stream...';

            const indicatorEl = document.getElementById('incomingAudioIndicator');
            console.log('[Dashboard] incomingAudioIndicator element:', indicatorEl);
            if (indicatorEl) indicatorEl.classList.add('active');

            // Add participant
            addParticipant({
                uuid: data.callUUID || data.uuid,
                name: data.caller || `Call ${(data.callUUID || data.uuid || '').substring(0, 8)}`,
                language: data.language || 'en'
            });

            // Start duration timer
            if (callDurationInterval) clearInterval(callDurationInterval);
            callDurationInterval = setInterval(updateCallDuration, 1000);

            // Start visualization
            drawIncomingVisualizer();
        }

        // Handle call disconnected
        function handleCallDisconnected(data) {
            if (filterExtension && data.extension !== filterExtension) return;
            console.log('[Dashboard] Call disconnected:', data);

            // Remove participant
            removeParticipant({
                uuid: data.callUUID || data.uuid || (currentCall && currentCall.callUUID)
            });

            currentCall = null;
            callStartTime = null;

            // Update UI
            const statusEl = document.getElementById('asteriskStreamStatus');
            statusEl.className = 'status-badge';
            statusEl.textContent = '‚è∏ Idle';
            statusEl.style.backgroundColor = '';  // Reset background
            statusEl.style.color = '';
            statusEl.style.fontWeight = '';
            statusEl.style.fontSize = '';
            document.getElementById('incomingAudioStatus').textContent = 'No active call';
            document.getElementById('incomingAudioIndicator').classList.remove('active');
            document.getElementById('translatedStreamStatus').className = 'status-badge';
            document.getElementById('translatedStreamStatus').textContent = '‚è∏ Idle';
            document.getElementById('outgoingAudioIndicator').classList.remove('active');

            // Stop duration timer
            if (callDurationInterval) {
                clearInterval(callDurationInterval);
                callDurationInterval = null;
            }

            // Stop visualizations
            if (incomingAnimationId) {
                cancelAnimationFrame(incomingAnimationId);
                incomingAnimationId = null;
            }
            if (outgoingAnimationId) {
                cancelAnimationFrame(outgoingAnimationId);
                outgoingAnimationId = null;
            }
            if (window.asteriskOutboundAnimating) {
                window.asteriskOutboundAnimating = false;
            }

            // Refresh recordings after call ends
            setTimeout(refreshRecordings, 2000);
        }

        // Update call duration
        function updateCallDuration() {
            if (!callStartTime) return;
            const duration = Math.floor((Date.now() - callStartTime) / 1000);
            const minutes = Math.floor(duration / 60);
            const seconds = duration % 60;
            document.getElementById('callDuration').textContent =
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // Draw incoming audio visualizer (waveform)
        function drawIncomingVisualizer() {
            const canvas = document.getElementById('incomingAudioViz');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            // Draw animated waveform
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            ctx.beginPath();

            const time = Date.now() / 1000;
            const amplitude = currentCall ? 30 + Math.random() * 20 : 5;

            for (let x = 0; x < width; x++) {
                const y = height / 2 + Math.sin((x / 30) + time * 2) * amplitude;
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();

            // Continue animation if call is active
            if (currentCall) {
                incomingAnimationId = requestAnimationFrame(drawIncomingVisualizer);
            }
        }

        // Draw outgoing audio visualizer
        function drawOutgoingVisualizer() {
            const canvas = document.getElementById('outgoingAudioViz');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            // Draw animated bars
            ctx.fillStyle = '#a78bfa';
            const barCount = 50;
            const barWidth = width / barCount;
            const time = Date.now() / 1000;

            for (let i = 0; i < barCount; i++) {
                const barHeight = (Math.sin(i / 5 + time * 3) + 1) * (height / 4);
                ctx.fillRect(i * barWidth, height - barHeight, barWidth - 2, barHeight);
            }

            // Continue animation if call is active
            if (currentCall) {
                outgoingAnimationId = requestAnimationFrame(drawOutgoingVisualizer);
            }
        }

        // Draw Asterisk outbound visualizer (Card #6)
        function drawAsteriskOutboundVisualizer() {
            const canvas = document.getElementById('asteriskOutboundViz');
            if (!canvas) {
                window.asteriskOutboundAnimating = false;
                return;
            }

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            // Draw animated waveform
            ctx.strokeStyle = '#5b6fd8';
            ctx.lineWidth = 3;
            ctx.beginPath();

            const time = Date.now() / 1000;
            const amplitude = 40;

            for (let x = 0; x < width; x++) {
                const y = height / 2 + Math.sin((x / 40) + time * 3) * amplitude * (0.8 + Math.random() * 0.2);
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();

            // Continue animation if still active
            if (window.asteriskOutboundAnimating) {
                requestAnimationFrame(drawAsteriskOutboundVisualizer);
            }
        }

        // Handle audio stream start
        function handleAudioStreamStart(data) {
            if (filterExtension && data.extension !== filterExtension) return;
            console.log('[Dashboard] Audio stream started:', data);
            if (data.direction === 'outgoing') {
                document.getElementById('translatedStreamStatus').className = 'status-badge status-operational';
                document.getElementById('translatedStreamStatus').textContent = 'üî¥ LIVE';
                document.getElementById('outgoingAudioStatus').textContent = 'Playing translated audio...';
                document.getElementById('outgoingAudioIndicator').classList.add('active');
                drawOutgoingVisualizer();
            }
        }

        // Handle audio stream data
        function handleAudioStreamData(data) {
            if (filterExtension && data.extension !== filterExtension) return;
            // This would handle raw audio data if needed
            // For now, we're using HTML5 audio elements with Socket.IO streams
        }

        // Handle audio stream end
        function handleAudioStreamEnd(data) {
            if (filterExtension && data.extension !== filterExtension) return;
            console.log('[Dashboard] Audio stream ended:', data);
            if (data.direction === 'outgoing') {
                document.getElementById('outgoingAudioIndicator').classList.remove('active');
            }
        }

        // Mute/unmute functions (start MUTED by default for browser autoplay policy)
        let incomingMuted = false;
        let outgoingMuted = false;

        function muteIncoming() {
            incomingMuted = !incomingMuted;
            const player = document.getElementById('incomingAudioPlayer');
            if (player) player.muted = incomingMuted;

            const btn = document.getElementById('incomingMuteBtn');
            btn.textContent = incomingMuted ? 'üîä Unmute' : 'üîá Mute';

            // When unmuting, resume AudioContext and reset play time to current (skip old buffered audio)
            if (!incomingMuted && incomingAudioContext) {
                // Resume AudioContext (browser autoplay policy)
                if (incomingAudioContext.state === 'suspended') {
                    incomingAudioContext.resume().then(() => {
                        console.log('[Incoming Audio] AudioContext resumed on unmute');
                    });
                }
                // Reset nextPlayTime to current time to avoid playing old buffered audio
                nextPlayTime = incomingAudioContext.currentTime;
                console.log('[Incoming Audio] Unmuted - will play live audio from current time');
            }
        }

        function muteOutgoing() {
            outgoingMuted = !outgoingMuted;
            const player = document.getElementById('outgoingAudioPlayer');
            if (player) player.muted = outgoingMuted;

            const btn = document.getElementById('outgoingMuteBtn');
            btn.textContent = outgoingMuted ? 'üîä Unmute' : 'üîá Mute';
        }

        // ============ HUME AI EMOTION DETECTION ============

        let emotionPlotCtx = null;
        let emotionPlotInitialized = false;

        // Initialize emotion plot canvas
        function initEmotionPlot() {
            if (emotionPlotInitialized) return;

            const canvas = document.getElementById('emotionPlot');
            if (!canvas) return;

            emotionPlotCtx = canvas.getContext('2d');
            emotionPlotInitialized = true;

            // Draw grid
            drawEmotionGrid();
        }

        function drawEmotionGrid() {
            if (!emotionPlotCtx) return;

            const canvas = emotionPlotCtx.canvas;
            const ctx = emotionPlotCtx;

            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Background
            ctx.fillStyle = '#f9fafb';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid lines
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 1;

            // Vertical center line
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();

            // Horizontal center line
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();

            // Quadrants background
            ctx.globalAlpha = 0.1;

            // Top-right (Excited + Positive)
            ctx.fillStyle = '#10b981';
            ctx.fillRect(canvas.width / 2, 0, canvas.width / 2, canvas.height / 2);

            // Top-left (Excited + Negative)
            ctx.fillStyle = '#ef4444';
            ctx.fillRect(0, 0, canvas.width / 2, canvas.height / 2);

            // Bottom-right (Calm + Positive)
            ctx.fillStyle = '#3b82f6';
            ctx.fillRect(canvas.width / 2, canvas.height / 2, canvas.width / 2, canvas.height / 2);

            // Bottom-left (Calm + Negative)
            ctx.fillStyle = '#6b7280';
            ctx.fillRect(0, canvas.height / 2, canvas.width / 2, canvas.height / 2);

            ctx.globalAlpha = 1.0;
        }

        function plotEmotionPoint(valence, arousal) {
            if (!emotionPlotCtx) {
                initEmotionPlot();
            }

            if (!emotionPlotCtx) return;

            const canvas = emotionPlotCtx.canvas;

            // Redraw grid
            drawEmotionGrid();

            // Convert valence (-1 to 1) and arousal (0 to 1) to canvas coordinates
            const x = ((valence + 1) / 2) * canvas.width;  // -1 to 1 ‚Üí 0 to width
            const y = (1 - arousal) * canvas.height;  // 1 to 0 ‚Üí 0 to height (inverted Y)

            // Draw point
            emotionPlotCtx.fillStyle = '#f59e0b';
            emotionPlotCtx.beginPath();
            emotionPlotCtx.arc(x, y, 8, 0, 2 * Math.PI);
            emotionPlotCtx.fill();

            // Draw ring
            emotionPlotCtx.strokeStyle = '#fff';
            emotionPlotCtx.lineWidth = 2;
            emotionPlotCtx.stroke();
        }

        // Handle emotion data from Hume AI
        function updateHumeEmotions(data) {
            console.log('[Dashboard] Emotion data received:', data);

            // Update status badge
            const statusBadge = document.getElementById('humeStatus');
            if (statusBadge) {
                statusBadge.textContent = 'üü¢ Active';
                statusBadge.style.color = '#10b981';
            }

            // Plot valence/arousal
            if (data.prosody) {
                plotEmotionPoint(data.prosody.valence, data.prosody.arousal);
            }

            // Display top 3 emotions
            if (data.emotions && data.emotions.length > 0) {
                const emotionBars = document.getElementById('emotionBars');
                if (emotionBars) {
                    emotionBars.innerHTML = data.emotions.slice(0, 3).map(emotion => `
                        <div class="emotion-bar">
                            <div class="emotion-bar-label">
                                <span>${emotion.name}</span>
                                <span>${(emotion.score * 100).toFixed(1)}%</span>
                            </div>
                            <div class="emotion-bar-fill" style="width: ${emotion.score * 100}%"></div>
                        </div>
                    `).join('');
                }
            }

            // Update prosody metrics
            if (data.prosody) {
                const pitchValue = document.getElementById('pitchValue');
                const energyValue = document.getElementById('energyValue');
                const rateValue = document.getElementById('rateValue');

                if (pitchValue && data.prosody.pitch) {
                    pitchValue.textContent = `${data.prosody.pitch.mean.toFixed(0)} Hz`;
                }

                if (energyValue && data.prosody.energy) {
                    energyValue.textContent = `${(data.prosody.energy.mean * 100).toFixed(0)}%`;
                }

                if (rateValue && data.prosody.speaking_rate) {
                    rateValue.textContent = `${data.prosody.speaking_rate.toFixed(1)} syl/sec`;
                }
            }

            // Update Hume service live status indicator (if exists)
            if (typeof updateHumeServiceStatus === 'function') {
                updateHumeServiceStatus(true);
            }
        }

        // Update Hume‚ÜíElevenLabs live status indicator

        // Update Hume AI service status indicator
        function updateHumeServiceStatus(active) {
            const pulseEl = document.getElementById('humeServicePulse');
            const textEl = document.getElementById('humeServiceText');
            
            if (!pulseEl || !textEl) return;
            
            if (active) {
                // Hume AI is processing audio
                pulseEl.style.background = '#10b981';
                pulseEl.style.boxShadow = '0 0 8px #10b981';
                pulseEl.style.animation = 'pulse 1.5s ease-in-out infinite';
                textEl.style.color = '#10b981';
                textEl.textContent = 'Hume: Active';
            } else {
                // Hume AI is idle
                pulseEl.style.background = '#666';
                pulseEl.style.boxShadow = 'none';
                pulseEl.style.animation = 'none';
                textEl.style.color = '#666';
                textEl.textContent = 'Hume: Waiting';
            }
        }
        function updateHumeToElevenLabsStatus(data) {
            const statusEl = document.getElementById('humeServiceStatus');
            const pulseEl = document.getElementById('humeServicePulse');
            const textEl = document.getElementById('humeServiceText');

            if (!statusEl || !pulseEl || !textEl) return;

            if (data.active) {
                // ElevenLabs is receiving FRESH Hume data
                pulseEl.style.background = '#10b981';
                pulseEl.style.boxShadow = '0 0 8px #10b981';
                pulseEl.style.animation = 'pulse 1.5s ease-in-out infinite';
                textEl.style.color = '#10b981';
                textEl.textContent = `Hume ‚Üí ElevenLabs (${data.emotionAge}ms)`;
                statusEl.style.borderColor = '#10b98144';

                console.log('[Hume‚ÜíElevenLabs] ACTIVE - Fresh emotion data applied to TTS:', data.voiceSettings);
            } else {
                // ElevenLabs is using STALE or no Hume data
                pulseEl.style.background = '#f59e0b';
                pulseEl.style.boxShadow = '0 0 6px #f59e0b';
                pulseEl.style.animation = 'none';
                textEl.style.color = '#f59e0b';
                textEl.textContent = data.emotionAge ? `Hume: Stale (${data.emotionAge}ms)` : 'Hume: No data';
                statusEl.style.borderColor = '#f59e0b44';

                console.log('[Hume‚ÜíElevenLabs] STALE - Using neutral fallback');
            }
        }

        // Visualize audio for Hume AI (same as Deepgram's fork)
        function visualizeHumeAudio(samples) {
            const canvas = document.getElementById('humeAudioViz');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = '#0f1419';
            ctx.fillRect(0, 0, width, height);

            // Draw waveform
            ctx.strokeStyle = '#51cf66';  // Green for Hume AI
            ctx.lineWidth = 2;
            ctx.beginPath();

            const step = Math.max(1, Math.floor(samples.length / width));
            for (let i = 0; i < width; i++) {
                const sampleIndex = i * step;
                const sample = samples[sampleIndex] || 0;
                const amplitude = Math.abs(sample / 32768.0);
                const y = height / 2 + (amplitude * height / 2) * (sample < 0 ? 1 : -1);

                if (i === 0) {
                    ctx.moveTo(i, y);
                } else {
                    ctx.lineTo(i, y);
                }
            }
            ctx.stroke();
        }

        // ============ PARTICIPANT MANAGEMENT ============

        let participants = new Map();

        // Add participant to the list
        function addParticipant(data) {
            console.log('[Participants] Adding participant:', data);

            const participantId = data.uuid || data.callUUID || data.id || `participant-${Date.now()}`;
            participants.set(participantId, {
                id: participantId,
                name: data.name || `Caller ${participantId.substring(0, 8)}`,
                language: data.language || 'en',
                joinedAt: Date.now(),
                speaking: false
            });

            refreshParticipantsList();
        }

        // Remove participant from the list
        function removeParticipant(data) {
            console.log('[Participants] Removing participant:', data);

            const participantId = data.uuid || data.callUUID || data.id;
            if (participantId) {
                participants.delete(participantId);
            }

            refreshParticipantsList();
        }

        // Refresh participants list UI
        function refreshParticipantsList() {
            const list = document.getElementById('participantsList');
            const count = document.getElementById('participantCount');

            count.textContent = participants.size;

            if (participants.size === 0) {
                list.innerHTML = `
                    <div class="loading">
                        <div class="loading-spinner"></div>
                        <div>Waiting for participants...</div>
                    </div>
                `;
                return;
            }

            list.innerHTML = Array.from(participants.values()).map(p => {
                const duration = Math.floor((Date.now() - p.joinedAt) / 1000);
                const minutes = Math.floor(duration / 60);
                const seconds = duration % 60;
                const durationStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                return `
                    <div class="participant">
                        <div class="participant-avatar">${p.name.charAt(0).toUpperCase()}</div>
                        <div class="participant-info">
                            <div class="participant-name">${p.name}</div>
                            <div class="participant-lang">Language: ${p.language} ‚Ä¢ Duration: ${durationStr}</div>
                        </div>
                        <div class="participant-status ${p.speaking ? 'speaking' : ''}"></div>
                    </div>
                `;
            }).join('');
        }

        // Update participant durations every second
        setInterval(() => {
            if (participants.size > 0) {
                refreshParticipantsList();
            }
        }, 1000);

        // ============ RECORDINGS MANAGEMENT ============

        let recordings = [];

        // Handle new recording ready
        function handleRecordingReady(data) {
            console.log('[Dashboard] Recording ready:', data);
            recordings.unshift(data);
            refreshRecordingsList();
        }

        // Refresh recordings from server
        async function refreshRecordings() {
            try {
                const response = await fetch('/api/recordings');
                const data = await response.json();
                recordings = data.recordings || [];
                refreshRecordingsList();
            } catch (err) {
                console.error('[Dashboard] Failed to fetch recordings:', err);
            }
        }

        // Refresh recordings list UI
        function refreshRecordingsList() {
            const list = document.getElementById('recordingList');

            if (recordings.length === 0) {
                list.innerHTML = '<div class="transcript-empty">üìÅ No recordings yet. Call recordings will appear here automatically.</div>';
                return;
            }

            list.innerHTML = recordings.map((rec, index) => `
                <div class="recording-item">
                    <div class="recording-icon">üéµ</div>
                    <div class="recording-info">
                        <div class="recording-title">Recording ${index + 1}</div>
                        <div class="recording-meta">
                            UUID: ${rec.uuid || rec.callUUID || 'Unknown'} ‚Ä¢
                            ${rec.duration || 'Unknown duration'} ‚Ä¢
                            ${new Date(rec.timestamp || rec.created || Date.now()).toLocaleString()}
                        </div>
                    </div>
                    <div class="recording-actions">
                        <button class="btn-icon" onclick="playRecording('${rec.filename || rec.path}')" title="Play">
                            ‚ñ∂Ô∏è
                        </button>
                        <button class="btn-icon" onclick="downloadRecording('${rec.filename || rec.path}')" title="Download">
                            ‚¨áÔ∏è
                        </button>
                        <button class="btn-icon delete" onclick="deleteRecording('${rec.filename || rec.path}')" title="Delete">
                            üóëÔ∏è
                        </button>
                    </div>
                </div>
            `).join('');
        }

        // Play recording
        function playRecording(filename) {
            const audio = new Audio(`/recordings/${filename}`);
            audio.play();
            console.log('[Dashboard] Playing recording:', filename);
        }

        // Download recording
        function downloadRecording(filename) {
            const a = document.createElement('a');
            a.href = `/recordings/${filename}`;
            a.download = filename;
            a.click();
            console.log('[Dashboard] Downloading recording:', filename);
        }

        // Delete recording
        async function deleteRecording(filename) {
            if (!confirm('Are you sure you want to delete this recording?')) return;

            try {
                await fetch(`/api/recordings/${filename}`, { method: 'DELETE' });
                recordings = recordings.filter(r => (r.filename || r.path) !== filename);
                refreshRecordingsList();
                console.log('[Dashboard] Deleted recording:', filename);
            } catch (err) {
                console.error('[Dashboard] Failed to delete recording:', err);
                alert('Failed to delete recording');
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            initDashboard();
            initAudioVisualizers();
            refreshRecordings();
            initEmotionPlot();
        });
    
        // ============================================
        // COMFORT NOISE CONTROL
        // ============================================

        // Flag to prevent feedback loop
        let isUpdatingFromServer = false;

        // Update display values only (no server communication)
        function updateComfortNoiseDisplay() {
            const enabled = document.getElementById('comfortNoiseEnabled').checked;
            const speechLevel = parseInt(document.getElementById('comfortSpeechLevel').value);
            const silenceLevel = parseInt(document.getElementById('comfortSilenceLevel').value);
            const fadeDuration = parseInt(document.getElementById('comfortFadeDuration').value);
            const bufferDelay = parseInt(document.getElementById('comfortBufferDelay').value);
            const vadThreshold = parseFloat(document.getElementById('comfortVadThreshold').value);

            // Update display values
            document.getElementById('comfortSpeechLevelValue').textContent = speechLevel + ' dB';
            document.getElementById('comfortSilenceLevelValue').textContent = silenceLevel + ' dB';
            document.getElementById('comfortFadeDurationValue').textContent = fadeDuration + ' ms';
            document.getElementById('comfortBufferDelayValue').textContent = bufferDelay + ' ms';
            document.getElementById('comfortVadThresholdValue').textContent = vadThreshold.toFixed(3);

            // Update status badge
            const statusBadge = document.getElementById('comfortNoiseStatus');
            if (enabled) {
                statusBadge.textContent = '‚úì Enabled';
                statusBadge.style.background = '#51cf66';
            } else {
                statusBadge.textContent = '‚úó Disabled';
                statusBadge.style.background = '#dc3545';
            }
        }

        // Send config to server (called by user interaction)
        function updateComfortNoiseConfig() {
            // Prevent feedback loop
            if (isUpdatingFromServer) {
                return;
            }

            const enabled = document.getElementById('comfortNoiseEnabled').checked;
            const noiseType = document.getElementById('comfortNoiseType').value;
            const speechLevel = parseInt(document.getElementById('comfortSpeechLevel').value);
            const silenceLevel = parseInt(document.getElementById('comfortSilenceLevel').value);
            const fadeDuration = parseInt(document.getElementById('comfortFadeDuration').value);
            const bufferDelay = parseInt(document.getElementById('comfortBufferDelay').value);
            const vadThreshold = parseFloat(document.getElementById('comfortVadThreshold').value);

            // Update display first
            updateComfortNoiseDisplay();

            const config = {
                enabled: enabled,
                noiseType: noiseType,
                speechLevel: speechLevel,
                silenceLevel: silenceLevel,
                fadeInMs: fadeDuration,
                fadeOutMs: fadeDuration,
                vadThreshold: vadThreshold,
                bufferDelay: bufferDelay
            };

            console.log('[ComfortNoise] Config updated:', config);

            // Send to server
            if (socket && socket.connected) {
                socket.emit('updateComfortNoise', config);
                console.log('[ComfortNoise] ‚úì Sent to server');
            } else {
                console.warn('[ComfortNoise] Socket not connected');
            }
        }

        // Listen for config updates from server
        socket.on('comfortNoiseConfig', (config) => {
            console.log('[ComfortNoise] Received config from server:', config);

            // Set flag to prevent feedback loop
            isUpdatingFromServer = true;

            // Update UI to match server config
            document.getElementById('comfortNoiseEnabled').checked = config.enabled;
            document.getElementById('comfortNoiseType').value = config.noiseType;
            document.getElementById('comfortSpeechLevel').value = config.speechLevel;
            document.getElementById('comfortSilenceLevel').value = config.silenceLevel;
            document.getElementById('comfortFadeDuration').value = config.fadeInMs;
            document.getElementById('comfortVadThreshold').value = config.vadThreshold;
            if (config.bufferDelay !== undefined) {
                document.getElementById('comfortBufferDelay').value = config.bufferDelay;
            }

            // Update display values (no server send)
            updateComfortNoiseDisplay();

            // Clear flag after a short delay
            setTimeout(() => {
                isUpdatingFromServer = false;
            }, 100);
        });


</script>
</body>
</html>
