<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Station Audio Monitoring</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .stations-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .station-card {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .station-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .station-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .station-id {
            font-size: 1.3em;
            font-weight: bold;
        }

        .extension-badge {
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-active {
            background: #4ade80;
            box-shadow: 0 0 10px #4ade80;
        }

        .status-inactive {
            background: #ef4444;
            box-shadow: 0 0 10px #ef4444;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .visualizations {
            display: grid;
            gap: 15px;
        }

        .viz-section {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 15px;
        }

        .viz-title {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        canvas {
            width: 100%;
            height: 100px;
            border-radius: 5px;
            background: rgba(0,0,0,0.3);
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .btn {
            padding: 10px 20px;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }

        .btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background: rgba(76, 175, 80, 0.7);
            border-color: #4caf50;
        }

        .btn-danger {
            background: rgba(244, 67, 54, 0.7);
            border-color: #f44336;
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .metric {
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .metric-label {
            font-size: 0.8em;
            opacity: 0.8;
            text-transform: uppercase;
        }

        .vu-meters {
            display: flex;
            gap: 5px;
            height: 100px;
            align-items: flex-end;
        }

        .vu-bar {
            flex: 1;
            background: linear-gradient(to top, #4ade80 0%, #facc15 50%, #ef4444 100%);
            border-radius: 2px;
            transition: height 0.05s;
        }

        .spectrum-bars {
            display: flex;
            gap: 2px;
            height: 100px;
            align-items: flex-end;
        }

        .spectrum-bar {
            flex: 1;
            background: linear-gradient(to top, #3b82f6, #8b5cf6);
            border-radius: 2px;
            transition: height 0.1s;
        }

        .connection-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéôÔ∏è Station Audio Monitoring System</h1>
            <p>Real-time Audio Streaming & Visualization</p>
        </div>

        <div class="stations-grid" id="stations-container">
            <!-- Station cards will be dynamically inserted here -->
        </div>

        <div class="connection-status" id="connection-status">
            <div class="status-indicator status-inactive" id="ws-status"></div>
            <span id="ws-text">Disconnected</span>
        </div>
    </div>

    <script>
        class StationAudioMonitor {
            constructor(stationId, extensionId, container) {
                this.stationId = stationId;
                this.extensionId = extensionId;
                this.container = container;
                this.audioContext = null;
                this.isPlaying = false;
                this.audioBuffer = [];
                this.ws = null;

                // Create UI
                this.createUI();

                // Initialize audio context on user interaction
                this.playBtn.addEventListener('click', () => this.toggleAudio());
            }

            createUI() {
                const card = document.createElement('div');
                card.className = 'station-card';
                card.innerHTML = `
                    <div class="station-header">
                        <div class="station-info">
                            <div class="status-indicator status-inactive" id="status-${this.extensionId}"></div>
                            <span class="station-id">${this.stationId}</span>
                            <span class="extension-badge">Ext: ${this.extensionId}</span>
                        </div>
                    </div>

                    <div class="controls">
                        <button class="btn btn-primary" id="play-${this.extensionId}">‚ñ∂ Play Audio</button>
                        <button class="btn" id="clear-${this.extensionId}">Clear Buffer</button>
                    </div>

                    <div class="visualizations">
                        <div class="viz-section">
                            <div class="viz-title">Waveform</div>
                            <canvas id="waveform-${this.extensionId}"></canvas>
                        </div>

                        <div class="viz-section">
                            <div class="viz-title">Spectrum Analyzer</div>
                            <div class="spectrum-bars" id="spectrum-${this.extensionId}">
                                ${Array(8).fill(0).map((_, i) =>
                                    `<div class="spectrum-bar" style="height: 0%"></div>`
                                ).join('')}
                            </div>
                        </div>

                        <div class="viz-section">
                            <div class="viz-title">VU Meter</div>
                            <div class="vu-meters" id="vu-${this.extensionId}">
                                ${Array(20).fill(0).map((_, i) =>
                                    `<div class="vu-bar" style="height: 0%"></div>`
                                ).join('')}
                            </div>
                        </div>
                    </div>

                    <div class="metrics">
                        <div class="metric">
                            <div class="metric-value" id="buffer-${this.extensionId}">0</div>
                            <div class="metric-label">Buffer Size</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value" id="latency-${this.extensionId}">0ms</div>
                            <div class="metric-label">Latency</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value" id="quality-${this.extensionId}">-</div>
                            <div class="metric-label">Quality</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value" id="packets-${this.extensionId}">0</div>
                            <div class="metric-label">Packets</div>
                        </div>
                    </div>
                `;

                this.container.appendChild(card);

                // Get UI elements
                this.playBtn = document.getElementById(`play-${this.extensionId}`);
                this.clearBtn = document.getElementById(`clear-${this.extensionId}`);
                this.statusIndicator = document.getElementById(`status-${this.extensionId}`);
                this.waveformCanvas = document.getElementById(`waveform-${this.extensionId}`);
                this.waveformCtx = this.waveformCanvas.getContext('2d');
                this.spectrumBars = document.querySelectorAll(`#spectrum-${this.extensionId} .spectrum-bar`);
                this.vuBars = document.querySelectorAll(`#vu-${this.extensionId} .vu-bar`);

                // Clear button
                this.clearBtn.addEventListener('click', () => {
                    this.audioBuffer = [];
                    this.updateMetric('buffer', 0);
                });
            }

            async toggleAudio() {
                if (!this.isPlaying) {
                    await this.startAudio();
                } else {
                    this.stopAudio();
                }
            }

            async startAudio() {
                // Initialize audio context
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // Connect to WebSocket
                this.connectWebSocket();

                this.isPlaying = true;
                this.playBtn.textContent = '‚è∏ Pause Audio';
                this.playBtn.classList.add('btn-danger');
                this.statusIndicator.classList.add('status-active');
                this.statusIndicator.classList.remove('status-inactive');

                // Start visualization
                this.startVisualization();
            }

            stopAudio() {
                if (this.ws) {
                    this.ws.close();
                }

                this.isPlaying = false;
                this.playBtn.textContent = '‚ñ∂ Play Audio';
                this.playBtn.classList.remove('btn-danger');
                this.statusIndicator.classList.remove('status-active');
                this.statusIndicator.classList.add('status-inactive');

                this.stopVisualization();
            }

            connectWebSocket() {
                const wsUrl = `ws://${window.location.hostname}:8099`;
                this.ws = new WebSocket(wsUrl);

                this.ws.onopen = () => {
                    console.log(`Connected to audio server for ${this.extensionId}`);
                    // Register for this extension's audio stream
                    this.ws.send(JSON.stringify({
                        type: 'subscribe',
                        extensionId: this.extensionId
                    }));
                };

                this.ws.onmessage = (event) => {
                    this.handleAudioData(event.data);
                };

                this.ws.onerror = (error) => {
                    console.error(`WebSocket error for ${this.extensionId}:`, error);
                };

                this.ws.onclose = () => {
                    console.log(`Disconnected from audio server for ${this.extensionId}`);
                    if (this.isPlaying) {
                        // Try to reconnect after 2 seconds
                        setTimeout(() => this.connectWebSocket(), 2000);
                    }
                };
            }

            async handleAudioData(data) {
                // Parse audio data
                if (data instanceof Blob) {
                    const arrayBuffer = await data.arrayBuffer();
                    this.processAudioBuffer(arrayBuffer);
                } else {
                    // Text message
                    try {
                        const msg = JSON.parse(data);
                        this.handleMessage(msg);
                    } catch (e) {
                        console.error('Failed to parse message:', e);
                    }
                }
            }

            processAudioBuffer(buffer) {
                // Add to buffer
                this.audioBuffer.push(buffer);

                // Keep buffer size manageable
                if (this.audioBuffer.length > 100) {
                    this.audioBuffer.shift();
                }

                this.updateMetric('buffer', this.audioBuffer.length);
                this.updateMetric('packets', parseInt(document.getElementById(`packets-${this.extensionId}`).textContent) + 1);

                // Play audio if context is ready
                if (this.audioContext && this.audioContext.state === 'running') {
                    this.playAudioBuffer(buffer);
                }
            }

            async playAudioBuffer(buffer) {
                try {
                    // Decode audio data
                    const audioBuffer = await this.audioContext.decodeAudioData(buffer.slice());

                    // Create source
                    const source = this.audioContext.createBufferSource();
                    source.buffer = audioBuffer;

                    // Connect to analyser for visualization
                    if (this.analyser) {
                        source.connect(this.analyser);
                    }

                    // Connect to output
                    source.connect(this.audioContext.destination);
                    source.start();

                } catch (e) {
                    console.error('Failed to play audio:', e);
                }
            }

            handleMessage(msg) {
                if (msg.type === 'metrics') {
                    this.updateMetric('latency', msg.latency + 'ms');
                    this.updateMetric('quality', msg.quality || '-');
                }
            }

            updateMetric(metric, value) {
                const element = document.getElementById(`${metric}-${this.extensionId}`);
                if (element) {
                    element.textContent = value;
                }
            }

            startVisualization() {
                // Create analyser
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 256;

                const bufferLength = this.analyser.frequencyBinCount;
                this.dataArray = new Uint8Array(bufferLength);

                this.visualize();
            }

            stopVisualization() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }

            visualize() {
                this.animationId = requestAnimationFrame(() => this.visualize());

                // Get frequency data
                this.analyser.getByteFrequencyData(this.dataArray);

                // Update spectrum bars
                const barCount = this.spectrumBars.length;
                const segmentSize = Math.floor(this.dataArray.length / barCount);

                for (let i = 0; i < barCount; i++) {
                    let sum = 0;
                    for (let j = 0; j < segmentSize; j++) {
                        sum += this.dataArray[i * segmentSize + j];
                    }
                    const average = sum / segmentSize;
                    const height = (average / 255) * 100;
                    this.spectrumBars[i].style.height = `${height}%`;
                }

                // Update VU meter
                let maxLevel = 0;
                for (let i = 0; i < this.dataArray.length; i++) {
                    if (this.dataArray[i] > maxLevel) {
                        maxLevel = this.dataArray[i];
                    }
                }

                const vuLevel = Math.floor((maxLevel / 255) * this.vuBars.length);
                for (let i = 0; i < this.vuBars.length; i++) {
                    const height = i < vuLevel ? '100%' : '0%';
                    this.vuBars[i].style.height = height;
                }

                // Draw waveform
                this.drawWaveform();
            }

            drawWaveform() {
                const width = this.waveformCanvas.width;
                const height = this.waveformCanvas.height;

                this.waveformCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.waveformCtx.fillRect(0, 0, width, height);

                this.analyser.getByteTimeDomainData(this.dataArray);

                this.waveformCtx.lineWidth = 2;
                this.waveformCtx.strokeStyle = '#4ade80';
                this.waveformCtx.beginPath();

                const sliceWidth = width / this.dataArray.length;
                let x = 0;

                for (let i = 0; i < this.dataArray.length; i++) {
                    const v = this.dataArray[i] / 128.0;
                    const y = v * height / 2;

                    if (i === 0) {
                        this.waveformCtx.moveTo(x, y);
                    } else {
                        this.waveformCtx.lineTo(x, y);
                    }

                    x += sliceWidth;
                }

                this.waveformCtx.lineTo(width, height / 2);
                this.waveformCtx.stroke();
            }
        }

        // Initialize stations
        const stations = [
            { id: 'STATION_3', extension: '3333' },
            { id: 'STATION_3', extension: '4444' }
        ];

        const stationsContainer = document.getElementById('stations-container');
        const monitors = {};

        stations.forEach(station => {
            monitors[station.extension] = new StationAudioMonitor(
                station.id,
                station.extension,
                stationsContainer
            );
        });

        // WebSocket connection status
        function updateConnectionStatus(connected) {
            const statusIndicator = document.getElementById('ws-status');
            const statusText = document.getElementById('ws-text');

            if (connected) {
                statusIndicator.classList.add('status-active');
                statusIndicator.classList.remove('status-inactive');
                statusText.textContent = 'Connected';
            } else {
                statusIndicator.classList.remove('status-active');
                statusIndicator.classList.add('status-inactive');
                statusText.textContent = 'Disconnected';
            }
        }

        // Check server connection
        setInterval(() => {
            fetch(`http://${window.location.hostname}:8099/health`)
                .then(() => updateConnectionStatus(true))
                .catch(() => updateConnectionStatus(false));
        }, 5000);
    </script>
</body>
</html>